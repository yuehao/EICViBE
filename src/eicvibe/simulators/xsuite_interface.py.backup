"""
XSuite simulation engine interface for EICViBE.

Provides integration with XSuite for particle tracking and beam dynamics simulations.
"""

import numpy as np
from typing import Dict, Any, Optional, List, Tuple, Callable
import logging
import threading
import queue
import time
from dataclasses import dataclass
from enum import Enum

# Import XSuite packages (handled in setup_simulator)
try:
    import xtrack as xt
    import xpart as xp
    import xobjects as xo
except ImportError:
    # Will be handled gracefully in setup_simulator
    xt = None
    xp = None  
    xo = None

from .base import SimulatorServiceBase, SimulationResult, RampingPlan, AsyncSimulatorBase, SimulationCommand, ElementUpdate, SimulationStatus
from eicvibe.machine_portal.lattice import Lattice

logger = logging.getLogger(__name__)


# Configuration constants
class XSuiteConfig:
    """Configuration constants for XSuite interface."""
    
    # Performance settings
    PAUSE_CHECK_INTERVAL = 0.01  # seconds
    COMMAND_CHECK_FREQUENCY = 10  # every N turns
    DEFAULT_STATISTICS_FREQUENCY = 100  # record stats every N turns (adjusts with num_turns)
    
    # Memory management
    MAX_MEMORY_PER_PARTICLE_MB = 0.1  # MB per particle for trajectory storage
    STREAMING_THRESHOLD_PARTICLES = 10000  # Use streaming above this threshold
    
    # Physics constants
    ELECTRON_MASS_EV = 0.51099895e6  # electron mass in eV
    SPEED_OF_LIGHT = 299792458  # m/s
    
    # Stability thresholds
    MAX_STABLE_BETA = 1000.0  # m
    MIN_POSITIVE_TUNE = 1e-6
    
    # Default tolerances
    EMITTANCE_CALCULATION_MIN_PARTICLES = 2
    PERIODICITY_TOLERANCE = 1e-6


class CircularBuffer:
    """High-performance circular buffer for turn-by-turn data storage."""
    
    def __init__(self, size: int):
        self.size = size
        self.buffer = [None] * size
        self.index = 0
        self.count = 0
        self.is_full = False
    
    def append(self, data):
        """Add data to buffer, overwriting oldest if full."""
        self.buffer[self.index] = data
        self.index = (self.index + 1) % self.size
        
        if not self.is_full:
            self.count += 1
            if self.count == self.size:
                self.is_full = True
    
    def get_latest(self, n: int = None) -> List:
        """Get the latest n items (or all if n is None)."""
        if self.count == 0:
            return []
        
        if n is None or n >= self.count:
            n = self.count
        
        items = []
        if self.is_full:
            # Buffer is full, data wraps around
            start_idx = (self.index - n) % self.size
            for i in range(n):
                items.append(self.buffer[(start_idx + i) % self.size])
        else:
            # Buffer not full, data is linear from start
            start_idx = max(0, self.count - n)
            items = self.buffer[start_idx:self.count]
        
        return items
    
    def get_all(self) -> List:
        """Get all data in chronological order."""
        return self.get_latest()
    
    def is_empty(self) -> bool:
        return self.count == 0


class AsyncRingSimulator(AsyncSimulatorBase):
    """
    XSuite-specific asynchronous ring simulation manager.
    
    Inherits generic communication infrastructure from AsyncSimulatorBase
    and implements XSuite-specific simulation logic with enhanced BPM tracking.
    """
    
    def __init__(self, xsuite_simulator, line, particles, sim_params):
        super().__init__(line, particles, sim_params)
        self.xsuite_sim = xsuite_simulator
        
        # Enhanced BPM tracking setup
        self.bpm_elements = self._find_bpm_elements()
        self.bpm_tracking_enabled = sim_params.get('track_bpms', True)
        self.bpm_buffer_size = sim_params.get('bpm_buffer_size', 1024)  # Default buffer for last N turns
        
        # Circular buffers for high-frequency turn-by-turn data
        self.bpm_data_buffers = {}  # {bpm_name: CircularBuffer}
        self.global_stats_buffer = None
        
        # Initialize BPM data structures
        self._initialize_bpm_tracking()
        
        # Performance optimization flags
        self.fast_bpm_tracking = sim_params.get('fast_bpm_tracking', True)
        self.bpm_update_frequency = sim_params.get('bpm_update_frequency', 1)  # Every N turns
    
    def _find_bpm_elements(self):
        """Find all beam position monitors in the lattice."""
        bpms = []
        for i, name in enumerate(self.line.element_names):
            element = self.line[name]
            if hasattr(element, '__class__'):
                class_name = element.__class__.__name__.lower()
                element_name = name.lower()
                
                # Identify BPMs by class name or element name patterns
                if (class_name in ['beampositionmonitor', 'monitor', 'bpm'] or
                    any(keyword in element_name for keyword in ['bpm', 'monitor', 'obs', 'ip'])):
                    
                    s_position = self.line.get_s_position(i) if hasattr(self.line, 'get_s_position') else float(i)
                    bpms.append({
                        'name': name,
                        'index': i,
                        's_position': s_position,
                        'element': element
                    })
        
        logger.info(f"Found {len(bpms)} BPM elements: {[bpm['name'] for bpm in bpms]}")
        return bpms
    
    def _initialize_bpm_tracking(self):
        """Initialize BPM data collection structures."""
        if not self.bpm_tracking_enabled or not self.bpm_elements:
            return
        
        # Create circular buffers for each BPM
        for bpm in self.bpm_elements:
            bpm_name = bpm['name']
            self.bpm_data_buffers[bpm_name] = CircularBuffer(self.bpm_buffer_size)
        
        # Global statistics buffer
        self.global_stats_buffer = CircularBuffer(self.bpm_buffer_size)
        
        logger.info(f"Initialized BPM tracking for {len(self.bpm_elements)} monitors with buffer size {self.bpm_buffer_size}")
    
    def get_bmp_statistics(self, bmp_name: str = None, last_n_turns: int = None) -> Dict[str, Any]:
        """Get BPM statistics for specific monitor and turn range.
        
        Args:
            bmp_name: Specific BPM name (None for all BPMs)
            last_n_turns: Number of recent turns to retrieve (None for all available)
            
        Returns:
            Dictionary with BPM data
        """
        if bmp_name:
            if bmp_name in self.bpm_data_buffers:
                buffer = self.bpm_data_buffers[bmp_name]
                data = buffer.get_latest(last_n_turns) if last_n_turns else buffer.get_all()
                return {bmp_name: data}
            else:
                return {}
        else:
            # Return all BPM data
            all_data = {}
            for bmp_name, buffer in self.bpm_data_buffers.items():
                data = buffer.get_latest(last_n_turns) if last_n_turns else buffer.get_all()
                all_data[bmp_name] = data
            return all_data
    
    def get_latest_bmp_reading(self, bmp_name: str = None) -> Dict[str, Any]:
        """Get the most recent BPM reading(s)."""
        if bmp_name:
            if bmp_name in self.bpm_data_buffers:
                buffer = self.bpm_data_buffers[bmp_name]
                latest_data = buffer.get_latest(1)
                return {bmp_name: latest_data[0] if latest_data else None}
            return {}
        else:
            # Get latest from all BPMs
            latest_all = {}
            for bmp_name, buffer in self.bpm_data_buffers.items():
                latest_data = buffer.get_latest(1)
                latest_all[bmp_name] = latest_data[0] if latest_data else None
            return latest_all
    
    def _simulation_loop(self, num_turns: int):
        """XSuite-specific simulation loop implementation with enhanced BPM tracking."""
        try:
            for turn in range(num_turns):
                if self.should_stop:
                    break
                
                # Wait if paused - use event-based waiting instead of busy polling
                while self.is_paused and not self.should_stop:
                    # Use threading.Event for efficient waiting
                    if hasattr(self, '_pause_event'):
                        self._pause_event.wait(timeout=0.1)
                    else:
                        time.sleep(0.01)
                
                if self.should_stop:
                    break
                
                self.current_turn = turn
                
                # Apply any pending parameter updates for this turn
                self._apply_pending_updates(turn)
                
                # Enhanced tracking with BPM data collection
                if self.bpm_tracking_enabled and self.bpm_elements and turn % self.bpm_update_frequency == 0:
                    self._track_with_bmp_monitoring(turn)
                else:
                    # Standard XSuite tracking
                    self.line.track(self.particles)
                
                # Record survival statistics
                survived = np.sum(self.particles.state > 0)
                survival_rate = survived / self.sim_params['num_particles']
                self.survival_history.append(survival_rate)
                
                # Collect global statistics and store in buffer
                if survived > 0:
                    surviving_particles = self.particles.state > 0
                    global_stats = {
                        'turn': turn,
                        'survival_rate': float(survival_rate),
                        'x_rms': float(np.std(self.particles.x[surviving_particles])),
                        'y_rms': float(np.std(self.particles.y[surviving_particles])),
                        'x_mean': float(np.mean(self.particles.x[surviving_particles])),
                        'y_mean': float(np.mean(self.particles.y[surviving_particles])),
                        'particles_alive': int(survived),
                        'timestamp': time.time()
                    }
                    
                    # Store in circular buffer for fast access
                    if self.global_stats_buffer:
                        self.global_stats_buffer.append(global_stats)
                    
                    # Legacy detailed statistics for status updates
                    if turn % max(1, num_turns // 100) == 0:
                        self.turn_data.append(global_stats)
                        
                        # Call status callback if provided
                        if self.status_callback:
                            status = self._get_current_status()
                            self.status_callback(status)
                
                # Call turn callback if provided
                if self.turn_callback:
                    self.turn_callback(turn, survival_rate, survived)
                
                # Add configurable delay between turns for demonstration
                if self.turn_delay > 0:
                    time.sleep(self.turn_delay)
                
                # Efficient command processing without fixed delays
                if turn % 10 == 0:  # Check every 10 turns
                    # Allow other threads to run without fixed delay
                    time.sleep(0)  # Yield to other threads
            
        except Exception as e:
            logger.error(f"Error in XSuite simulation loop: {e}")
        finally:
            self.is_running = False
            logger.info(f"XSuite simulation loop completed at turn {self.current_turn}")
    
    def _track_with_bmp_monitoring(self, turn: int):
        """Track particles through lattice with BPM data collection at each monitor."""
        # Option 1: Fast tracking with post-analysis (for high-speed simulations)
        if self.fast_bpm_tracking:
            # Standard full-turn tracking
            self.line.track(self.particles)
            
            # Collect BPM data by "rewinding" and tracking to each BPM position
            # This is more efficient for fast simulations
            self._collect_bmp_data_fast_mode(turn)
        else:
            # Option 2: Element-by-element tracking (more accurate but slower)
            self._track_element_by_element_with_bmp_data(turn)
    
    def _collect_bmp_data_fast_mode(self, turn: int):
        """Fast BPM data collection using particle state snapshots."""
        # For fast simulations, we track the full turn first, then collect data
        # This prevents missing turns but may be less accurate for BPM positions
        
        for bpm_info in self.bpm_elements:
            bpm_data = self._estimate_bmp_data_from_current_state(bpm_info, turn)
            if bpm_data:
                bpm_name = bpm_info['name']
                if bpm_name in self.bpm_data_buffers:
                    self.bpm_data_buffers[bpm_name].append(bpm_data)
    
    def _track_element_by_element_with_bmp_data(self, turn: int):
        """Track element by element and collect precise BPM data."""
        # This method is more accurate but slower - suitable for detailed analysis
        
        bmp_indices = {bmp['index']: bmp for bmp in self.bmp_elements}
        
        # Track through each element and collect BPM data where appropriate
        for i, element_name in enumerate(self.line.element_names):
            element = self.line[element_name]
            
            # Track through this element
            element.track(self.particles)
            
            # If this is a BPM location, collect data
            if i in bmp_indices:
                bmp_info = bmp_indices[i]
                bmp_data = self._collect_bmp_data_at_element(bmp_info, turn)
                if bmp_data:
                    bmp_name = bmp_info['name']
                    if bmp_name in self.bpm_data_buffers:
                        self.bpm_data_buffers[bmp_name].append(bmp_data)
    
    def _estimate_bmp_data_from_current_state(self, bmp_info: dict, turn: int) -> dict:
        """Estimate BPM data from current particle state (fast mode approximation)."""
        surviving_particles = self.particles.state > 0
        if not np.any(surviving_particles):
            return None
        
        # For fast mode, we use the current particle state as approximation
        # This isn't perfectly accurate for BPM position but maintains high speed
        x = self.particles.x[surviving_particles]
        y = self.particles.y[surviving_particles]
        px = self.particles.px[surviving_particles]
        py = self.particles.py[surviving_particles]
        
        return {
            'turn': turn,
            'timestamp': time.time(),
            'bmp_name': bmp_info['name'],
            's_position': bmp_info['s_position'],
            'particles_alive': int(np.sum(surviving_particles)),
            'mode': 'fast_approximation',
            
            # Position statistics
            'x_mean': float(np.mean(x)),
            'y_mean': float(np.mean(y)),
            'x_rms': float(np.std(x)),
            'y_rms': float(np.std(y)),
            'x_max': float(np.max(np.abs(x))),
            'y_max': float(np.max(np.abs(y))),
            
            # Momentum statistics  
            'px_mean': float(np.mean(px)),
            'py_mean': float(np.mean(py)),
            'px_rms': float(np.std(px)),
            'py_rms': float(np.std(py)),
        }
    
    def _collect_bmp_data_at_element(self, bmp_info: dict, turn: int) -> dict:
        """Collect precise particle statistics at a specific BPM location."""
        surviving_particles = self.particles.state > 0
        if not np.any(surviving_particles):
            return None
        
        # Extract surviving particle data
        x = self.particles.x[surviving_particles]
        y = self.particles.y[surviving_particles]
        px = self.particles.px[surviving_particles]
        py = self.particles.py[surviving_particles]
        
        # Calculate statistics
        bmp_stats = {
            'turn': turn,
            'timestamp': time.time(),
            'bmp_name': bmp_info['name'],
            's_position': bmp_info['s_position'],
            'particles_alive': int(np.sum(surviving_particles)),
            'mode': 'precise',
            
            # Position statistics
            'x_mean': float(np.mean(x)),
            'y_mean': float(np.mean(y)),
            'x_rms': float(np.std(x)),
            'y_rms': float(np.std(y)),
            'x_max': float(np.max(np.abs(x))),
            'y_max': float(np.max(np.abs(y))),
            
            # Momentum statistics  
            'px_mean': float(np.mean(px)),
            'py_mean': float(np.mean(py)),
            'px_rms': float(np.std(px)),
            'py_rms': float(np.std(py)),
            
            # Beam size and emittance approximation
            'beam_size_x': float(np.std(x)),
            'beam_size_y': float(np.std(y)),
        }
        
        # Calculate normalized emittance approximation (simplified)
        try:
            if len(x) > 2:
                # Simplified emittance calculation (geometric mean)
                emit_x = float(np.sqrt(np.var(x) * np.var(px) - np.cov(x, px)[0,1]**2))
                emit_y = float(np.sqrt(np.var(y) * np.var(py) - np.cov(y, py)[0,1]**2))
                bmp_stats['emittance_x'] = emit_x
                bmp_stats['emittance_y'] = emit_y
        except:
            bmp_stats['emittance_x'] = 0.0
            bmp_stats['emittance_y'] = 0.0
        
        return bmp_stats
    
    def _apply_element_update(self, update: ElementUpdate):
        """XSuite-specific parameter update implementation."""
        # Find the element in the line
        if update.element_name not in self.line.element_names:
            raise ValueError(f"Element '{update.element_name}' not found in lattice")
        
        element = self.line[update.element_name]
        
        # Apply the parameter update based on element type and parameter
        # This maps to the XSuite parameter structure
        if hasattr(element, update.parameter_name):
            setattr(element, update.parameter_name, update.new_value)
        else:
            # Handle nested parameters (e.g., k1 for quadrupoles)
            if update.parameter_group == "MagneticMultipoleP":
                if update.parameter_name == "kn1" and hasattr(element, 'k1'):
                    element.k1 = update.new_value
                elif update.parameter_name == "kn2" and hasattr(element, 'k2'):
                    element.k2 = update.new_value
                elif update.parameter_name == "kn3" and hasattr(element, 'k3'):
                    element.k3 = update.new_value
                else:
                    raise ValueError(f"Parameter '{update.parameter_name}' not supported for element type")
            elif update.parameter_group == "BendP":
                if update.parameter_name == "angle" and hasattr(element, 'angle'):
                    element.angle = update.new_value
                else:
                    raise ValueError(f"Parameter '{update.parameter_name}' not supported for bend element")
            else:
                raise ValueError(f"Parameter group '{update.parameter_group}' not supported")
        
        logger.info(f"Updated {update.element_name}.{update.parameter_name} = {update.new_value}")
    
    def _get_current_status(self) -> SimulationStatus:
        """XSuite-specific status collection."""
        elapsed_time = time.time() - self.start_time if self.start_time else 0.0
        survived = np.sum(self.particles.state > 0) if hasattr(self.particles, 'state') else 0
        survival_rate = survived / self.sim_params['num_particles'] if self.sim_params['num_particles'] > 0 else 0.0
        
        # Calculate current beam statistics for surviving particles
        beam_stats = {}
        if survived > 0:
            surviving_particles = self.particles.state > 0
            beam_stats = {
                'x_rms': float(np.std(self.particles.x[surviving_particles])),
                'y_rms': float(np.std(self.particles.y[surviving_particles])),
                'x_mean': float(np.mean(self.particles.x[surviving_particles])),
                'y_mean': float(np.mean(self.particles.y[surviving_particles]))
            }
        
        return SimulationStatus(
            is_running=self.is_running,
            is_paused=self.is_paused,
            current_turn=self.current_turn,
            total_turns=self.sim_params.get('num_turns', 0),
            survival_rate=survival_rate,
            elapsed_time=elapsed_time,
            particles_alive=survived,
            beam_statistics=beam_stats
        )
    
    def _save_particle_snapshot(self) -> Dict[str, Any]:
        """XSuite-specific particle snapshot."""
        surviving_particles = self.particles.state > 0
        snapshot = {
            'turn': self.current_turn,
            'timestamp': time.time(),
            'total_particles': self.sim_params['num_particles'],
            'alive_particles': int(np.sum(surviving_particles)),
            'particle_data': {
                'x': self.particles.x[surviving_particles].tolist(),
                'y': self.particles.y[surviving_particles].tolist(),
                'px': self.particles.px[surviving_particles].tolist(),
                'py': self.particles.py[surviving_particles].tolist(),
                'zeta': self.particles.zeta[surviving_particles].tolist(),
                'delta': self.particles.delta[surviving_particles].tolist()
            }
        }
        return snapshot

    def get_global_statistics(self, last_n_turns: int = None) -> List[Dict[str, Any]]:
        """Get global beam statistics for the last N turns.
        
        Args:
            last_n_turns: Number of recent turns to retrieve (None for all available)
            
        Returns:
            List of turn statistics dictionaries
        """
        if not self.global_stats_buffer:
            return []
        
        data = self.global_stats_buffer.get_latest(last_n_turns) if last_n_turns else self.global_stats_buffer.get_all()
        return data if data else []


class XSuiteSimulator(SimulatorServiceBase):
    """
    XSuite simulation service for EICViBE.
    
    Provides continuous particle tracking and beam dynamics simulations using XSuite.
    """
    
    def __init__(self, name: str = "XSuite", **kwargs):
        super().__init__(name, **kwargs)
        
        # XSuite-specific attributes
        self.xsuite_available = False
        self.xtrack = None
        self.xpart = None
        self.xobjects = None
        
        # Default simulation parameters
        self.default_params = {
            'num_particles': 1000,
            'num_turns': 100,
            'reference_particle': {
                'particle_ref': 'electron',
                'p0c': 5e9,  # 5 GeV electron
                'q0': -1,
                'mass0': 0.51099895e6  # electron mass in eV
            },
            'initial_distribution': {
                'x_norm': 1e-6,      # 1 μm
                'px_norm': 1e-8,     # 1 μrad
                'y_norm': 1e-6,      # 1 μm  
                'py_norm': 1e-8,     # 1 μrad
                'zeta': 1e-3,        # 1 mm
                'delta': 1e-4        # 0.01%
            },
            'tracking_method': 'auto',
            'save_at_elements': [],
            'save_particles': True
        }
    
    def setup_simulator(self) -> bool:
        """Set up XSuite simulation engine."""
        try:
            # Import XSuite packages
            import xtrack as xt
            import xpart as xp
            import xobjects as xo
            
            self.xtrack = xt
            self.xpart = xp  
            self.xobjects = xo
            self.xsuite_available = True
            
            logger.info("XSuite packages imported successfully")
            return True
            
        except ImportError as e:
            logger.error(f"Failed to import XSuite: {e}")
            logger.error("Please install XSuite: pip install xsuite")
            self.xsuite_available = False
            return False
        except Exception as e:
            logger.error(f"Error setting up XSuite: {e}")
            return False
    
    def convert_lattice(self, lattice: Lattice, branch_name: str = None) -> Any:
        """
        Convert EICViBE lattice to XSuite Line object.
        
        Args:
            lattice: EICViBE lattice
            branch_name: Branch to convert. If None or if no branches exist, uses all elements
            
        Returns:
            XSuite Line object
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Get elements from the specified branch or all elements if no branches exist
        try:
            if branch_name is not None and lattice.branches:
                elements = lattice.select_elements(branch_name=branch_name)
            else:
                # If no branch specified or no branches exist, use all elements
                elements = list(lattice.elements.values())
        except ValueError as e:
            if "Branch" in str(e) and "does not exist" in str(e):
                # Branch doesn't exist, fall back to all elements
                elements = list(lattice.elements.values())
                logger.warning(f"Branch '{branch_name}' not found, using all lattice elements")
            else:
                raise e
        
        # Convert elements to XSuite format
        xsuite_elements = {}
        element_names = []
        
        for i, element in enumerate(elements):
            xs_element = self._convert_element_to_xsuite(element)
            element_name = element.name
            
            # Handle name conflicts
            if element_name in xsuite_elements:
                element_name = f"{element.name}_{i}"
            
            xsuite_elements[element_name] = xs_element
            element_names.append(element_name)
        
        # Create XSuite Line
        line = self.xtrack.Line(
            elements=xsuite_elements,
            element_names=element_names
        )
        
        logger.info(f"Converted {len(elements)} elements to XSuite Line")
        return line
    
    def _convert_element_to_xsuite(self, element) -> Any:
        """Convert a single EICViBE element to XSuite element."""
        element_type = element.type.lower()
        
        if element_type == 'drift':
            return self.xtrack.Drift(length=element.length)
        
        elif element_type == 'quadrupole':
            # Get magnetic parameters
            mag_group = element.get_parameter_group("MagneticMultipoleP")
            k1 = mag_group.get_parameter("kn1") if mag_group else None
            k1 = k1 if k1 is not None else 0.0
            
            return self.xtrack.Quadrupole(
                length=element.length,
                k1=k1
            )
        
        elif element_type == 'sextupole':
            mag_group = element.get_parameter_group("MagneticMultipoleP")
            k2 = mag_group.get_parameter("kn2") if mag_group else None
            k2 = k2 if k2 is not None else 0.0
            
            return self.xtrack.Sextupole(
                length=element.length,
                k2=k2
            )
        
        elif element_type == 'octupole':
            mag_group = element.get_parameter_group("MagneticMultipoleP")
            k3 = mag_group.get_parameter("kn3") if mag_group else None
            k3 = k3 if k3 is not None else 0.0
            
            return self.xtrack.Octupole(
                length=element.length,
                k3=k3
            )
        
        elif element_type in ['bend', 'rbend']:
            # Get geometric parameters
            geom_group = element.get_parameter_group("BendP")
            angle = geom_group.get_parameter("angle") if geom_group else None
            angle = angle if angle is not None else 0.0
            
            # Get magnetic parameters
            mag_group = element.get_parameter_group("MagneticMultipoleP")
            k1 = mag_group.get_parameter("kn1") if mag_group else None
            k1 = k1 if k1 is not None else 0.0
            
            if element_type == 'bend':
                return self.xtrack.Bend(
                    length=element.length,
                    k0=angle/element.length if element.length > 0 else 0.0,
                    k1=k1
                )
            else:  # rbend
                # XSuite uses RBend, not RectangularBend
                return self.xtrack.RBend(
                    length=element.length,
                    angle=angle,
                    k1=k1
                )
        
        elif element_type == 'rfcavity':
            rf_group = element.get_parameter_group("RFP")
            voltage = rf_group.get_parameter("voltage") if rf_group else None
            frequency = rf_group.get_parameter("freq") if rf_group else None  # EICViBE uses "freq" not "frequency"
            phase = rf_group.get_parameter("phase") if rf_group else None
            voltage = voltage if voltage is not None else 0.0
            frequency = frequency if frequency is not None else 1e9
            phase = phase if phase is not None else 0.0
            
            return self.xtrack.Cavity(
                voltage=voltage,
                frequency=frequency,
                lag=phase / (2 * np.pi)  # Convert phase to lag
            )
        
        elif element_type == 'monitor':
            # XSuite BeamPositionMonitor is better for general beam monitoring
            # than ParticlesMonitor which is more for particle trajectory tracking
            return self.xtrack.BeamPositionMonitor()
        
        elif element_type == 'marker':
            return self.xtrack.Marker()
        
        elif element_type == 'solenoid':
            # Get solenoid parameters
            sol_group = element.get_parameter_group("SolenoidP")
            ks = sol_group.get_parameter("ks") if sol_group else None
            ks = ks if ks is not None else 0.0
            
            return self.xtrack.Solenoid(
                length=element.length,
                ks=ks
            )
        
        elif element_type in ['kicker', 'ackicker']:
            # Get kicker parameters
            kick_group = element.get_parameter_group("KickerP")
            hkick = kick_group.get_parameter("hkick") if kick_group else None
            vkick = kick_group.get_parameter("vkick") if kick_group else None
            hkick = hkick if hkick is not None else 0.0
            vkick = vkick if vkick is not None else 0.0
            
            # Use XYShift for static kicks
            return self.xtrack.XYShift(dx=hkick, dy=vkick)
        
        elif element_type == 'multipole':
            # Get multipole parameters
            mag_group = element.get_parameter_group("MagneticMultipoleP")
            if mag_group:
                # Extract multipole coefficients
                knl = []
                ksl = []
                max_order = 10  # Check up to decapole
                
                for n in range(max_order + 1):
                    kn = mag_group.get_parameter(f"kn{n}") 
                    ks = mag_group.get_parameter(f"ks{n}")
                    knl.append(kn if kn is not None else 0.0)
                    ksl.append(ks if ks is not None else 0.0)
                
                return self.xtrack.Multipole(
                    length=element.length,
                    knl=knl,
                    ksl=ksl
                )
            else:
                return self.xtrack.Multipole(length=element.length, knl=[0], ksl=[0])
        
        elif element_type == 'crabcavity':
            # Get RF parameters for crab cavity
            rf_group = element.get_parameter_group("RFP")
            voltage = rf_group.get_parameter("voltage") if rf_group else None
            frequency = rf_group.get_parameter("freq") if rf_group else None  # EICViBE uses "freq" not "frequency"
            phase = rf_group.get_parameter("phase") if rf_group else None
            voltage = voltage if voltage is not None else 0.0
            frequency = frequency if frequency is not None else 1e9
            phase = phase if phase is not None else 0.0
            
            # Use RFMultipole for crab cavity (transverse RF)
            return self.xtrack.RFMultipole(
                voltage=voltage,
                frequency=frequency,
                lag=phase / (2 * np.pi),
                knl=[0, voltage/1e6]  # Transverse kick
            )
        
        else:
            # Default: treat as drift
            logger.warning(f"Unknown element type '{element_type}', treating as drift")
            return self.xtrack.Drift(length=element.length)
    
    def _get_reference_particle(self, parameters: Dict[str, Any]) -> Any:
        """Get reference particle with guaranteed required parameters."""
        # Merge with default parameters (deep merge for nested dicts)
        sim_params = self.default_params.copy()
        for key, value in parameters.items():
            if key in sim_params and isinstance(sim_params[key], dict) and isinstance(value, dict):
                # Deep merge for nested dictionaries
                sim_params[key] = {**sim_params[key], **value}
            else:
                sim_params[key] = value
        
        ref_params = sim_params['reference_particle']
        
        return self.xpart.Particles(
            p0c=ref_params['p0c'],
            q0=ref_params.get('q0', -1),  # Default for electrons
            mass0=ref_params.get('mass0', 0.51099895e6)  # Electron mass in eV
        )

    def run_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run XSuite particle tracking simulation.
        
        Args:
            sim_lattice: XSuite Line object
            parameters: Simulation parameters
            
        Returns:
            Dictionary containing simulation results
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Merge with default parameters (deep merge for nested dicts)
        sim_params = self.default_params.copy()
        for key, value in parameters.items():
            if key in sim_params and isinstance(sim_params[key], dict) and isinstance(value, dict):
                # Deep merge for nested dictionaries
                sim_params[key] = {**sim_params[key], **value}
            else:
                sim_params[key] = value
        
        # Build reference particle
        ref_params = sim_params['reference_particle']
        
        particle_ref = self.xpart.Particles(
            p0c=ref_params['p0c'],
            q0=ref_params.get('q0', -1),  # Default for electrons
            mass0=ref_params.get('mass0', 0.51099895e6)  # Electron mass in eV
        )
        
        # Build the line with reference particle
        line = sim_lattice
        line.particle_ref = particle_ref
        
        # Build the tracker
        line.build_tracker()
        
        # Generate initial particle distribution
        particles = self._generate_particle_distribution(
            line.particle_ref,
            sim_params['num_particles'],
            sim_params['initial_distribution']
        )
        
        # Track particles
        num_turns = sim_params['num_turns']
        
        # Set up monitoring
        if sim_params['save_particles']:
            # Save particle data at each turn
            x_data = np.zeros((num_turns + 1, sim_params['num_particles']))
            y_data = np.zeros((num_turns + 1, sim_params['num_particles']))
            px_data = np.zeros((num_turns + 1, sim_params['num_particles']))
            py_data = np.zeros((num_turns + 1, sim_params['num_particles']))
            zeta_data = np.zeros((num_turns + 1, sim_params['num_particles']))
            delta_data = np.zeros((num_turns + 1, sim_params['num_particles']))
            
            # Save initial conditions
            x_data[0] = particles.x
            y_data[0] = particles.y
            px_data[0] = particles.px
            py_data[0] = particles.py
            zeta_data[0] = particles.zeta
            delta_data[0] = particles.delta
        
        # Perform tracking
        survived_particles = particles.state > 0
        
        for turn in range(num_turns):
            line.track(particles)
            
            # Check for lost particles
            current_survived = particles.state > 0
            newly_lost = survived_particles & (~current_survived)
            
            if sim_params['save_particles']:
                x_data[turn + 1] = particles.x
                y_data[turn + 1] = particles.y
                px_data[turn + 1] = particles.px
                py_data[turn + 1] = particles.py
                zeta_data[turn + 1] = particles.zeta
                delta_data[turn + 1] = particles.delta
            
            survived_particles = current_survived
        
        # Calculate final statistics
        survival_rate = np.sum(survived_particles) / sim_params['num_particles']
        
        # Calculate beam parameters (for surviving particles only)
        if np.any(survived_particles):
            final_x = particles.x[survived_particles]
            final_y = particles.y[survived_particles]
            final_px = particles.px[survived_particles]
            final_py = particles.py[survived_particles]
            
            beam_stats = {
                'x_mean': float(np.mean(final_x)),
                'x_std': float(np.std(final_x)),
                'y_mean': float(np.mean(final_y)),
                'y_std': float(np.std(final_y)),
                'px_mean': float(np.mean(final_px)),
                'px_std': float(np.std(final_px)),
                'py_mean': float(np.mean(final_py)),
                'py_std': float(np.std(final_py))
            }
            
            # Calculate emittances safely with specific error handling
            try:
                if len(final_x) > 1 and len(final_px) > 1:  # Need at least 2 particles for covariance
                    emitt_x_sq = np.var(final_x) * np.var(final_px) - np.cov(final_x, final_px)[0,1]**2
                    emitt_y_sq = np.var(final_y) * np.var(final_py) - np.cov(final_y, final_py)[0,1]**2
                    beam_stats['emittance_x'] = float(np.sqrt(max(0, emitt_x_sq)))
                    beam_stats['emittance_y'] = float(np.sqrt(max(0, emitt_y_sq)))
                else:
                    beam_stats['emittance_x'] = 0.0
                    beam_stats['emittance_y'] = 0.0
            except (ValueError, np.linalg.LinAlgError) as e:
                logger.warning(f"Emittance calculation failed: {e}")
                beam_stats['emittance_x'] = 0.0
                beam_stats['emittance_y'] = 0.0
        else:
            beam_stats = {key: 0.0 for key in ['x_mean', 'x_std', 'y_mean', 'y_std', 
                                             'px_mean', 'px_std', 'py_mean', 'py_std',
                                             'emittance_x', 'emittance_y']}
        
        # Prepare results
        result_data = {
            'simulation_type': 'particle_tracking',
            'num_particles': sim_params['num_particles'],
            'num_turns': num_turns,
            'survival_rate': survival_rate,
            'beam_statistics': beam_stats,
            'lattice_length': float(line.get_length()),
            'simulation_parameters': sim_params
        }
        
        # Add particle trajectory data if requested
        if sim_params['save_particles']:
            result_data['particle_trajectories'] = {
                'x': x_data.tolist(),
                'y': y_data.tolist(),
                'px': px_data.tolist(),
                'py': py_data.tolist(),
                'zeta': zeta_data.tolist(),
                'delta': delta_data.tolist(),
                'turns': list(range(num_turns + 1))
            }
        
        logger.info(f"XSuite simulation completed: {survival_rate:.1%} survival rate")
        return result_data
    
    def _generate_particle_distribution(self, ref_particle: Any, num_particles: int, 
                                       dist_params: Dict[str, float]) -> Any:
        """Generate initial particle distribution."""
        
        # Generate Gaussian distributions
        x = np.random.normal(0, dist_params['x_norm'], num_particles)
        px = np.random.normal(0, dist_params['px_norm'], num_particles)
        y = np.random.normal(0, dist_params['y_norm'], num_particles)
        py = np.random.normal(0, dist_params['py_norm'], num_particles)
        zeta = np.random.normal(0, dist_params['zeta'], num_particles)
        delta = np.random.normal(0, dist_params['delta'], num_particles)
        
        # Extract scalar values from reference particle (XSuite may return arrays)
        p0c = ref_particle.p0c[0] if hasattr(ref_particle.p0c, '__len__') else ref_particle.p0c
        q0 = getattr(ref_particle, 'q0', None)
        mass0 = getattr(ref_particle, 'mass0', None)
        
        # Use defaults if not available from reference particle
        if q0 is None:
            q0 = -1  # Default for electrons
        if mass0 is None:
            mass0 = 0.51099895e6  # Electron mass in eV        # Create particles with the reference particle settings
        particles = self.xpart.Particles(
            _capacity=num_particles,
            p0c=p0c,
            q0=q0,
            mass0=mass0,
            x=x,
            px=px,
            y=y,
            py=py,
            zeta=zeta,
            delta=delta
        )
        
        return particles
    
    def run_linac_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run LINAC mode simulation with continuous particle generation.
        
        In LINAC mode, particles are continuously generated at the beginning
        and tracked through the lattice. When particles reach the end,
        new particles are generated.
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Get LINAC-specific parameters
        generation_rate = parameters.get('generation_rate', 1000.0)  # particles/second
        continuous_duration = parameters.get('continuous_duration', 10.0)  # seconds
        
        # Get reference particle with safe parameter handling
        particle_ref = self._get_reference_particle(parameters)
        
        # Merge with default parameters for other settings
        sim_params = {**self.default_params, **parameters}
        
        # Calculate total particles to generate
        total_particles = int(generation_rate * continuous_duration)
        batch_size = sim_params.get('batch_size', 1000)
        
        line = sim_lattice
        line.particle_ref = particle_ref
        line.build_tracker()
        
        # Storage for results
        all_survival_rates = []
        all_beam_stats = []
        total_generated = 0
        
        logger.info(f"Starting LINAC simulation: {generation_rate} p/s for {continuous_duration}s")
        
        # Generate and track particles in batches
        for batch_start in range(0, total_particles, batch_size):
            batch_end = min(batch_start + batch_size, total_particles)
            batch_particles = batch_end - batch_start
            
            # Generate particle batch
            particles = self._generate_particle_distribution(
                particle_ref, batch_particles, sim_params['initial_distribution']
            )
            
            # Track through lattice (single pass)
            line.track(particles)
            
            # Calculate batch statistics
            survived = np.sum(particles.state > 0)
            survival_rate = survived / batch_particles
            all_survival_rates.append(survival_rate)
            
            if survived > 0:
                final_x = particles.x[particles.state > 0]
                final_y = particles.y[particles.state > 0]
                final_px = particles.px[particles.state > 0]
                final_py = particles.py[particles.state > 0]
                
                batch_stats = {
                    'x_mean': float(np.mean(final_x)),
                    'x_std': float(np.std(final_x)),
                    'y_mean': float(np.mean(final_y)),
                    'y_std': float(np.std(final_y)),
                    'px_mean': float(np.mean(final_px)),
                    'px_std': float(np.std(final_px)),
                    'py_mean': float(np.mean(final_py)),
                    'py_std': float(np.std(final_py))
                }
                all_beam_stats.append(batch_stats)
            
            total_generated = batch_end
        
        # Calculate overall statistics
        overall_survival_rate = np.mean(all_survival_rates)
        
        result_data = {
            'simulation_type': 'linac_tracking',
            'generation_rate': generation_rate,
            'continuous_duration': continuous_duration,
            'total_particles_generated': total_generated,
            'batches_processed': len(all_survival_rates),
            'overall_survival_rate': float(overall_survival_rate),
            'batch_survival_rates': [float(sr) for sr in all_survival_rates],
            'lattice_length': float(line.get_length()),
            'beam_statistics': all_beam_stats[-1] if all_beam_stats else {},
            'simulation_parameters': sim_params
        }
        
        logger.info(f"LINAC simulation completed: {overall_survival_rate:.1%} average survival")
        return result_data
    
    def run_ring_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run RING mode simulation with continuous particle tracking.
        
        In RING mode, particles are generated initially and tracked continuously
        in the ring for the specified duration.
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Check if asynchronous mode is requested
        async_mode = parameters.get('async_mode', False)
        
        if async_mode:
            return self._run_async_ring_simulation(sim_lattice, parameters)
        else:
            return self._run_sync_ring_simulation(sim_lattice, parameters)
    
    def _run_async_ring_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run asynchronous ring simulation with real-time communication support.
        """
        # Merge with default parameters (deep merge for nested dicts)
        sim_params = self.default_params.copy()
        for key, value in parameters.items():
            if key in sim_params and isinstance(sim_params[key], dict) and isinstance(value, dict):
                # Deep merge for nested dictionaries
                sim_params[key] = {**sim_params[key], **value}
            else:
                sim_params[key] = value
        
        # Build reference particle and line
        ref_params = sim_params['reference_particle']
        
        # Ensure required parameters are present
        if 'q0' not in ref_params:
            ref_params['q0'] = -1
        if 'mass0' not in ref_params:
            ref_params['mass0'] = 0.51099895e6
        
        particle_ref = self.xpart.Particles(
            p0c=ref_params['p0c'],
            q0=ref_params['q0'],
            mass0=ref_params['mass0']
        )
        
        line = sim_lattice
        line.particle_ref = particle_ref
        line.build_tracker()
        
        # Generate initial particle distribution
        particles = self._generate_particle_distribution(
            particle_ref, sim_params['num_particles'], sim_params['initial_distribution']
        )
        
        # Calculate number of turns
        max_turns = parameters.get('max_turns', sim_params.get('num_turns', 1000))
        num_turns = min(max_turns, sim_params.get('num_turns', max_turns))
        
        # Create async simulator
        async_sim = AsyncRingSimulator(self, line, particles, sim_params)
        
        # Set up callbacks if provided
        turn_callback = parameters.get('turn_callback')
        status_callback = parameters.get('status_callback')
        
        # Start the simulation
        async_sim.start_simulation(
            num_turns=num_turns,
            turn_callback=turn_callback,
            status_callback=status_callback
        )
        
        # Store reference for external access
        self._current_async_sim = async_sim
        
        logger.info(f"Started asynchronous RING simulation for {num_turns} turns")
        
        # Return immediately with async simulator handle
        return {
            'simulation_type': 'async_ring_tracking',
            'async_simulator': async_sim,
            'num_turns': num_turns,
            'status': 'started',
            'lattice_length': float(line.get_length()),
            'simulation_parameters': sim_params
        }
    
    def _run_sync_ring_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run synchronous ring simulation (original implementation).
        """
        # Get RING-specific parameters
        continuous_duration = parameters.get('continuous_duration', 100.0)  # seconds
        
        # Merge with default parameters (deep merge for nested dicts)
        sim_params = self.default_params.copy()
        for key, value in parameters.items():
            if key in sim_params and isinstance(sim_params[key], dict) and isinstance(value, dict):
                # Deep merge for nested dictionaries
                sim_params[key] = {**sim_params[key], **value}
            else:
                sim_params[key] = value
        
        # Calculate number of turns based on duration and revolution time
        # Estimate revolution time from lattice length and particle velocity
        ref_params = sim_params['reference_particle']
        
        # Ensure required parameters are present
        if 'q0' not in ref_params:
            # Default charge for electrons
            ref_params['q0'] = -1
        if 'mass0' not in ref_params:
            # Default mass for electrons (in eV)
            ref_params['mass0'] = 0.51099895e6
        
        particle_ref = self.xpart.Particles(
            p0c=ref_params['p0c'],
            q0=ref_params['q0'],
            mass0=ref_params['mass0']
        )
        
        line = sim_lattice
        line.particle_ref = particle_ref
        line.build_tracker()
        
        # Estimate revolution time (simplified)
        lattice_length = line.get_length()
        c_light = 299792458  # m/s
        beta = ref_params['p0c'] / np.sqrt(ref_params['p0c']**2 + ref_params['mass0']**2)
        revolution_time = lattice_length / (beta * c_light)
        
        # Limit the number of turns for reasonable simulation time
        max_turns = parameters.get('max_turns', sim_params.get('num_turns', 1000))
        estimated_turns = int(continuous_duration / revolution_time)
        num_turns = min(estimated_turns, max_turns)
        
        # Adjust duration if we're limiting turns
        effective_duration = num_turns * revolution_time
        
        logger.info(f"RING simulation: {continuous_duration}s ≈ {estimated_turns} turns, limited to {num_turns}")
        
        # Generate initial particle distribution
        particles = self._generate_particle_distribution(
            particle_ref, sim_params['num_particles'], sim_params['initial_distribution']
        )
        
        # Track particles for multiple turns
        survival_history = []
        turn_data = []
        
        for turn in range(num_turns):
            line.track(particles)
            
            # Record survival statistics
            survived = np.sum(particles.state > 0)
            survival_rate = survived / sim_params['num_particles']
            survival_history.append(survival_rate)
            
            # Record beam statistics every N turns
            if turn % max(1, num_turns // 100) == 0 and survived > 0:
                surviving_particles = particles.state > 0
                turn_stats = {
                    'turn': turn,
                    'survival_rate': float(survival_rate),
                    'x_rms': float(np.std(particles.x[surviving_particles])),
                    'y_rms': float(np.std(particles.y[surviving_particles]))
                }
                turn_data.append(turn_stats)
        
        # Final statistics
        final_survival_rate = survival_history[-1] if survival_history else 0.0
        
        result_data = {
            'simulation_type': 'sync_ring_tracking',
            'continuous_duration': continuous_duration,
            'effective_duration': effective_duration,
            'num_turns': num_turns,
            'estimated_turns': estimated_turns,
            'revolution_time': revolution_time,
            'initial_particles': sim_params['num_particles'],
            'final_survival_rate': float(final_survival_rate),
            'survival_history': [float(sr) for sr in survival_history],
            'turn_statistics': turn_data,
            'lattice_length': float(lattice_length),
            'simulation_parameters': sim_params
        }
        
        logger.info(f"RING simulation completed: {final_survival_rate:.1%} final survival after {num_turns} turns")
        return result_data
    
    def run_ramping_simulation(self, sim_lattice: Any, ramping_plan: RampingPlan, 
                             parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run RAMPING mode simulation with time-dependent parameters.
        
        In RAMPING mode, element parameters change according to the ramping plan
        while particles are tracked through the time-varying lattice.
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Get RAMPING-specific parameters
        # Merge with default parameters (deep merge for nested dicts)
        sim_params = self.default_params.copy()
        for key, value in parameters.items():
            if key in sim_params and isinstance(sim_params[key], dict) and isinstance(value, dict):
                # Deep merge for nested dictionaries
                sim_params[key] = {**sim_params[key], **value}
            else:
                sim_params[key] = value
        
        ramping_duration = ramping_plan.duration
        time_steps = parameters.get('time_steps', 100)
        dt = ramping_duration / time_steps
        
        # Build reference particle and tracker
        ref_params = sim_params['reference_particle']
        
        # Ensure required parameters are present
        if 'q0' not in ref_params:
            # Default charge for electrons
            ref_params['q0'] = -1
        if 'mass0' not in ref_params:
            # Default mass for electrons (in eV)
            ref_params['mass0'] = 0.51099895e6
        
        particle_ref = self.xpart.Particles(
            p0c=ref_params['p0c'],
            q0=ref_params['q0'],
            mass0=ref_params['mass0']
        )
        
        line = sim_lattice
        line.particle_ref = particle_ref
        line.build_tracker()
        
        # Generate initial particle distribution
        particles = self._generate_particle_distribution(
            particle_ref, sim_params['num_particles'], sim_params['initial_distribution']
        )
        
        logger.info(f"RAMPING simulation: {ramping_duration}s with {time_steps} steps")
        
        # Storage for ramping results
        time_history = []
        survival_history = []
        parameter_history = []
        
        # Track through ramping sequence
        for step in range(time_steps):
            current_time = step * dt
            
            # Update element parameters according to ramping plan
            # Note: This is a placeholder implementation
            # Real implementation would modify line elements based on ramping_plan
            
            # Track particles for this time step
            line.track(particles)
            
            # Record statistics
            survived = np.sum(particles.state > 0)
            survival_rate = survived / sim_params['num_particles']
            
            time_history.append(current_time)
            survival_history.append(survival_rate)
            
            # Record parameter values (placeholder)
            param_snapshot = {
                'time': current_time,
                'example_parameter': ramping_plan.get_parameter_at_time('Q1', 'k1', current_time)
            }
            parameter_history.append(param_snapshot)
        
        # Final statistics
        final_survival_rate = survival_history[-1] if survival_history else 0.0
        
        result_data = {
            'simulation_type': 'ramping_tracking',
            'ramping_plan_name': ramping_plan.name,
            'ramping_duration': ramping_duration,
            'time_steps': time_steps,
            'dt': dt,
            'initial_particles': sim_params['num_particles'],
            'final_survival_rate': float(final_survival_rate),
            'time_history': time_history,
            'survival_history': [float(sr) for sr in survival_history],
            'parameter_history': parameter_history,
            'lattice_length': float(line.get_length()),
            'simulation_parameters': sim_params
        }
        
        logger.info(f"RAMPING simulation completed: {final_survival_rate:.1%} final survival after {ramping_duration}s")
        return result_data
    
    def cleanup_simulator(self):
        """Clean up XSuite resources."""
        # Stop any running async simulation
        if hasattr(self, '_current_async_sim') and self._current_async_sim:
            try:
                self._current_async_sim.stop_simulation()
                self._current_async_sim.wait_for_completion()
            except:
                pass
        
        # XSuite doesn't require explicit cleanup
        logger.info("XSuite simulator cleaned up")
    
    # Async simulation control methods
    def get_async_simulation_status(self) -> Optional[SimulationStatus]:
        """Get status of currently running async simulation."""
        if hasattr(self, '_current_async_sim') and self._current_async_sim:
            try:
                return self._current_async_sim.get_status()
            except:
                return None
        return None
    
    def update_element_in_running_simulation(self, element_name: str, 
                                           parameter_group: str, 
                                           parameter_name: str, 
                                           new_value: float,
                                           target_turn: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an element parameter in the currently running async simulation.
        
        Args:
            element_name: Name of the element to update
            parameter_group: Parameter group (e.g., "MagneticMultipoleP", "BendP")
            parameter_name: Parameter name (e.g., "kn1", "angle")
            new_value: New parameter value
            target_turn: Turn number to apply the update (None for immediate)
            
        Returns:
            Response from the simulation
        """
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        return self._current_async_sim.update_element_parameter(
            element_name=element_name,
            parameter_group=parameter_group,
            parameter_name=parameter_name,
            new_value=new_value,
            target_turn=target_turn
        )
    
    def pause_running_simulation(self) -> Dict[str, Any]:
        """Pause the currently running async simulation."""
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        return self._current_async_sim.pause_simulation()
    
    def resume_running_simulation(self) -> Dict[str, Any]:
        """Resume the currently paused async simulation."""
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        return self._current_async_sim.resume_simulation()
    
    def stop_running_simulation(self) -> Dict[str, Any]:
        """Stop the currently running async simulation."""
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        return self._current_async_sim.stop_simulation()
    
    def get_particle_snapshot(self) -> Dict[str, Any]:
        """Get current particle snapshot from running simulation."""
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        return self._current_async_sim.get_particle_snapshot()
    
    def get_bmp_readings_during_simulation(self, bmp_names: List[str] = None, 
                                         last_n_turns: int = 1024) -> Dict[str, Any]:
        """Get BPM readings from currently running async simulation.
        
        Args:
            bmp_names: List of specific BPM names (None for all BPMs)
            last_n_turns: Number of recent turns to retrieve (default: 1024)
            
        Returns:
            Dictionary with BMP data for requested monitors and turns
        """
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        if bmp_names:
            # Get data for specific BPMs
            all_data = {}
            for bmp_name in bmp_names:
                bmp_data = self._current_async_sim.get_bmp_statistics(bmp_name, last_n_turns)
                all_data.update(bmp_data)
            return all_data
        else:
            # Get data for all BPMs
            return self._current_async_sim.get_bmp_statistics(None, last_n_turns)
    
    def get_latest_bmp_readings(self, bmp_names: List[str] = None) -> Dict[str, Any]:
        """Get the most recent BPM readings from all or specified monitors.
        
        Args:
            bmp_names: List of specific BPM names (None for all BPMs)
            
        Returns:
            Dictionary with latest BMP readings
        """
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        if bmp_names:
            all_latest = {}
            for bmp_name in bmp_names:
                latest = self._current_async_sim.get_latest_bmp_reading(bmp_name)
                all_latest.update(latest)
            return all_latest
        else:
            return self._current_async_sim.get_latest_bmp_reading()
    
    def get_global_beam_statistics(self, last_n_turns: int = 1024) -> List[Dict[str, Any]]:
        """Get global beam statistics for last N turns.
        
        Args:
            last_n_turns: Number of recent turns to retrieve
            
        Returns:
            List of turn statistics dictionaries
        """
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        return self._current_async_sim.get_global_statistics(last_n_turns)
    
    def stream_bmp_data(self, callback: Callable[[Dict], None], 
                       bmp_names: List[str] = None,
                       update_interval: int = 1) -> None:
        """Stream BPM data to a callback function in real-time.
        
        Args:
            callback: Function to call with BMP data updates
            bmp_names: List of specific BPM names (None for all BPMs)
            update_interval: Update frequency in turns (1 = every turn)
        """
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        def bmp_callback(turn, survival_rate, particles_alive):
            if turn % update_interval == 0:
                if bmp_names:
                    latest_readings = {}
                    for bmp_name in bmp_names:
                        reading = self._current_async_sim.get_latest_bmp_reading(bmp_name)
                        latest_readings.update(reading)
                else:
                    latest_readings = self._current_async_sim.get_latest_bmp_reading()
                
                if latest_readings:
                    callback({
                        'turn': turn,
                        'bmp_readings': latest_readings,
                        'global_survival_rate': survival_rate,
                        'particles_alive': particles_alive,
                        'timestamp': time.time()
                    })
        
        # Set the callback on the async simulator
        self._current_async_sim.turn_callback = bmp_callback
    
    def monitor_all_bpms_realtime(self, callback: Callable[[Dict], None], 
                                update_interval: int = 1) -> None:
        """Monitor all BPMs in real-time with comprehensive data.
        
        Args:
            callback: Function to call with comprehensive BMP data
            update_interval: Update frequency in turns
        """
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        def comprehensive_callback(turn, survival_rate, particles_alive):
            if turn % update_interval == 0:
                # Get latest BMP readings
                bmp_readings = self._current_async_sim.get_latest_bmp_reading()
                
                # Get latest global statistics
                global_stats = self._current_async_sim.get_global_statistics(1)
                latest_global = global_stats[0] if global_stats else {}
                
                if bmp_readings or latest_global:
                    callback({
                        'turn': turn,
                        'bmp_readings': bmp_readings,
                        'global_statistics': latest_global,
                        'survival_rate': survival_rate,
                        'particles_alive': particles_alive,
                        'timestamp': time.time(),
                        'bmp_count': len(bmp_readings)
                    })
        
        # Set the callback on the async simulator
        self._current_async_sim.turn_callback = comprehensive_callback
    
    def wait_for_simulation_completion(self, check_interval: float = 1.0) -> Dict[str, Any]:
        """
        Wait for the async simulation to complete and return results.
        
        Args:
            check_interval: Time interval (seconds) between status checks
            
        Returns:
            Final simulation results
        """
        if not hasattr(self, '_current_async_sim') or not self._current_async_sim:
            raise RuntimeError("No async simulation is currently running")
        
        # Wait for completion
        self._current_async_sim.wait_for_completion()
        
        # Get final results
        results = self._current_async_sim.get_results()
        
        # Clean up reference
        self._current_async_sim = None
        
        return results
    
    def get_beam_optics(self, lattice: Lattice, branch_name: str = "main", 
                       parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Calculate beam optics functions (Twiss parameters) using XSuite.
        
        For ring lattices, automatically attempts to find periodic boundary conditions where
        optics functions have the periodicity of the pass length. Falls back to initial
        conditions for non-rings or unstable configurations.
        
        Based on XSuite documentation: https://xsuite.readthedocs.io/en/latest/twiss.html#basic-usage-ring
        
        Args:
            lattice: EICViBE lattice
            branch_name: Branch to analyze
            parameters: Optional parameters for Twiss calculation
            
        Returns:
            Dictionary containing comprehensive optics functions with proper periodicity for rings
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Merge with default parameters
        twiss_params = {
            'reference_particle': {
                'p0c': 5e9,  # 5 GeV
                'q0': -1,    # electron
                'mass0': 0.51099895e6  # electron mass in eV
            },
            'method': '6d',  # Use 6D method by default
            'betx': 1.0,      # Initial beta_x [m]
            'bety': 1.0,      # Initial beta_y [m]
            'alfx': 0.0,      # Initial alpha_x
            'alfy': 0.0,      # Initial alpha_y
            'dx': 0.0,        # Initial dispersion_x [m]
            'dpx': 0.0,       # Initial dispersion_px
            'dy': 0.0,        # Initial dispersion_y [m]
            'dpy': 0.0,       # Initial dispersion_py
            'compute_chromatic_functions': False,  # Disable by default for stability
            'radiation_method': None,
            'eneloss_and_damping': False,
            'continue_on_closed_orbit_error': True,  # Continue even if not perfect ring
            'force_periodic': False,  # Force periodic solution attempt
            'is_ring': None  # Auto-detect if not specified
        }
        
        if parameters:
            # Deep merge for nested dictionaries
            for key, value in parameters.items():
                if key in twiss_params and isinstance(twiss_params[key], dict) and isinstance(value, dict):
                    twiss_params[key] = {**twiss_params[key], **value}
                else:
                    twiss_params[key] = value
        
        # Convert lattice
        line = self.convert_lattice(lattice, branch_name)
        
        # Build reference particle
        ref_params = twiss_params['reference_particle']
        ref_particle = self.xpart.Particles(
            p0c=ref_params['p0c'],
            q0=ref_params['q0'],
            mass0=ref_params['mass0']
        )
        line.particle_ref = ref_particle
        line.build_tracker()
        
        # Auto-detect if this is a ring lattice if not explicitly specified
        is_ring = twiss_params['is_ring']
        if is_ring is None:
            # Heuristic: if lattice starts and ends at similar positions, treat as ring
            # Also check for typical ring elements or naming conventions
            lattice_elements = lattice.get_elements()
            element_names = [elem.name.lower() for elem in lattice_elements]
            
            # Look for ring indicators
            ring_keywords = ['ring', 'sector', 'bend', 'arc', 'dipole']
            has_ring_elements = any(keyword in name for name in element_names for keyword in ring_keywords)
            
            # Check if we have bending elements (rings typically have dipoles)
            has_bends = any(elem.element_type.lower() in ['bend', 'rbend', 'sbend', 'dipole'] 
                          for elem in lattice_elements)
            
            is_ring = has_ring_elements or has_bends or twiss_params['force_periodic']
        
        logger.info(f"Calculating Twiss parameters for lattice with {len(line.element_names)} elements")
        if is_ring:
            logger.info("Treating as ring lattice - attempting periodic boundary conditions")
        else:
            logger.info("Treating as transport line - using initial conditions")
        
        try:
            # For ring lattices, prioritize periodic solution
            if is_ring or twiss_params['force_periodic']:
                try:
                    # Try periodic solution first (for rings)
                    logger.info("Attempting periodic solution for ring lattice...")
                    twiss = line.twiss(
                        method=twiss_params['method'],
                        compute_chromatic_properties=twiss_params['compute_chromatic_functions'],
                        continue_on_closed_orbit_error=twiss_params['continue_on_closed_orbit_error']
                    )
                    calculation_mode = "periodic_ring"
                    logger.info("✅ Periodic solution successful - optics functions have proper ring periodicity")
                    
                except (ValueError, RuntimeError) as e:
                    logger.warning(f"Periodic solution failed: {e}")
                    logger.info("Ring lattice unstable or incomplete - falling back to initial conditions...")
                    
                    # Fall back to initial conditions even for rings if periodic fails
                    twiss = line.twiss(
                        method=twiss_params['method'],
                        betx=twiss_params['betx'],
                        bety=twiss_params['bety'],
                        alfx=twiss_params['alfx'],
                        alfy=twiss_params['alfy'],
                        dx=twiss_params['dx'],
                        dpx=twiss_params['dpx'],
                        dy=twiss_params['dy'],
                        dpy=twiss_params['dpy'],
                        compute_chromatic_properties=False,  # Disable for stability
                        continue_on_closed_orbit_error=True
                    )
                    calculation_mode = "initial_conditions_ring_fallback"
            else:
                # For transport lines, use initial conditions directly
                logger.info("Using initial conditions for transport line...")
                twiss = line.twiss(
                    method=twiss_params['method'],
                    betx=twiss_params['betx'],
                    bety=twiss_params['bety'],
                    alfx=twiss_params['alfx'],
                    alfy=twiss_params['alfy'],
                    dx=twiss_params['dx'],
                    dpx=twiss_params['dpx'],
                    dy=twiss_params['dy'],
                    dpy=twiss_params['dpy'],
                    compute_chromatic_properties=False,  # Always disable for non-periodic
                    continue_on_closed_orbit_error=True
                )
                calculation_mode = "initial_conditions"
            
            # Extract comprehensive optics data
            optics_data = {
                # Basic Twiss functions
                's': twiss.s.tolist(),
                'betx': twiss.betx.tolist(),
                'bety': twiss.bety.tolist(),
                'alfx': twiss.alfx.tolist(),
                'alfy': twiss.alfy.tolist(),
                'gamx': twiss.gamx.tolist(),
                'gamy': twiss.gamy.tolist(),
                
                # Phase advances
                'mux': twiss.mux.tolist(),
                'muy': twiss.muy.tolist(),
                
                # Dispersion functions
                'dx': twiss.dx.tolist(),
                'dy': twiss.dy.tolist(),
                'dpx': twiss.dpx.tolist(),
                'dpy': twiss.dpy.tolist(),
                
                # Element information
                'element_names': twiss.name.tolist(),
                
                # Lattice metadata
                'lattice_length': float(line.get_length()),
                'num_elements': len(line.element_names),
                'calculation_mode': calculation_mode,
                'is_ring': is_ring,
                'reference_particle': {
                    'p0c': float(ref_params['p0c']),
                    'q0': float(ref_params['q0']),
                    'mass0': float(ref_params['mass0'])
                }
            }
            
            # Add global parameters based on calculation mode
            if calculation_mode == "periodic_ring":
                # True periodic solution - all ring properties available
                try:
                    optics_data['tune_x'] = float(twiss.qx)
                    optics_data['tune_y'] = float(twiss.qy)
                    
                    # Ring-specific properties
                    if hasattr(twiss, 'momentum_compaction_factor'):
                        optics_data['momentum_compaction'] = float(twiss.momentum_compaction_factor)
                    if hasattr(twiss, 'circumference'):
                        optics_data['circumference'] = float(twiss.circumference)
                    
                    # Verify periodicity of optics functions
                    periodicity_check = self._verify_periodicity(twiss)
                    optics_data['periodicity_verified'] = periodicity_check['is_periodic']
                    optics_data['periodicity_errors'] = periodicity_check['max_errors']
                    
                    # Add phase advances for completeness
                    optics_data['phase_advance_x'] = float(twiss.mux[-1] - twiss.mux[0])
                    optics_data['phase_advance_y'] = float(twiss.muy[-1] - twiss.muy[0])
                    
                    logger.info(f"✅ Ring periodicity verified: βx error = {periodicity_check['max_errors']['betx']:.2e}")
                    
                except Exception as e:
                    logger.warning(f"Some global ring parameters not available: {e}")
                    
            else:
                # Non-periodic or fallback calculation
                phase_advance_x = float(twiss.mux[-1] - twiss.mux[0])
                phase_advance_y = float(twiss.muy[-1] - twiss.muy[0])
                optics_data['phase_advance_x'] = phase_advance_x
                optics_data['phase_advance_y'] = phase_advance_y
                
                # Provide tune-like quantities for compatibility
                optics_data['tune_x'] = phase_advance_x / (2 * np.pi)  # Convert to tune units
                optics_data['tune_y'] = phase_advance_y / (2 * np.pi)
                
                # Mark as non-periodic
                optics_data['periodicity_verified'] = False
                optics_data['periodicity_errors'] = {'note': 'Non-periodic calculation'}
            
            # Add chromaticity if computed successfully
            if twiss_params['compute_chromatic_functions'] and hasattr(twiss, 'dqx'):
                try:
                    optics_data['chromaticity_x'] = float(twiss.dqx)
                    optics_data['chromaticity_y'] = float(twiss.dqy)
                except:
                    logger.warning("Chromaticity calculation failed")
            
            # Add statistics
            optics_data['statistics'] = {
                'max_betx': float(np.max(twiss.betx)),
                'min_betx': float(np.min(twiss.betx)),
                'max_bety': float(np.max(twiss.bety)),
                'min_bety': float(np.min(twiss.bety)),
                'max_dx': float(np.max(np.abs(twiss.dx))),
                'max_dy': float(np.max(np.abs(twiss.dy))),
                'final_phase_x': float(twiss.mux[-1]),
                'final_phase_y': float(twiss.muy[-1])
            }
            
            mode_msg = "periodic ring solution" if calculation_mode == "periodic_ring" else "with initial conditions"
            logger.info(f"Twiss calculation completed ({mode_msg})")
            
        except Exception as e:
            logger.error(f"Twiss calculation failed: {e}")
            raise RuntimeError(f"Failed to calculate Twiss parameters: {e}")
        
        return optics_data
    
    def _verify_periodicity(self, twiss) -> Dict[str, Any]:
        """
        Verify that optics functions satisfy ring periodicity conditions.
        
        For a proper ring solution, optics functions should return to their
        initial values after one complete pass.
        
        Args:
            twiss: XSuite Twiss object from periodic calculation
            
        Returns:
            Dictionary with periodicity verification results
        """
        try:
            # Check if first and last values match (within tolerance)
            tolerance = 1e-10  # Very tight tolerance for periodic solutions
            
            errors = {}
            
            # Check beta functions
            errors['betx'] = abs(twiss.betx[0] - twiss.betx[-1])
            errors['bety'] = abs(twiss.bety[0] - twiss.bety[-1])
            
            # Check alpha functions
            errors['alfx'] = abs(twiss.alfx[0] - twiss.alfx[-1])
            errors['alfy'] = abs(twiss.alfy[0] - twiss.alfy[-1])
            
            # Check dispersion functions
            errors['dx'] = abs(twiss.dx[0] - twiss.dx[-1])
            errors['dy'] = abs(twiss.dy[0] - twiss.dy[-1])
            errors['dpx'] = abs(twiss.dpx[0] - twiss.dpx[-1])
            errors['dpy'] = abs(twiss.dpy[0] - twiss.dpy[-1])
            
            # Overall periodicity check
            max_error = max(errors.values())
            is_periodic = max_error < tolerance
            
            return {
                'is_periodic': is_periodic,
                'max_errors': errors,
                'max_error_value': max_error,
                'tolerance': tolerance
            }
            
        except Exception as e:
            logger.warning(f"Periodicity verification failed: {e}")
            return {
                'is_periodic': False,
                'max_errors': {'error': str(e)},
                'max_error_value': float('inf'),
                'tolerance': tolerance
            }
    
    def get_ring_optics(self, lattice: Lattice, branch_name: str = "main",
                       parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Calculate beam optics for a ring lattice with enforced periodic boundary conditions.
        
        This method specifically targets ring lattices and enforces periodic solutions
        where optics functions have the periodicity of the ring circumference.
        
        Args:
            lattice: EICViBE ring lattice
            branch_name: Branch to analyze
            parameters: Optional parameters for calculation
            
        Returns:
            Dictionary with periodic ring optics or raises error if not achievable
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Force ring treatment and periodic solution
        ring_params = {
            'is_ring': True,
            'force_periodic': True,
            'compute_chromatic_functions': True,  # Enable for full ring analysis
            **(parameters or {})
        }
        
        logger.info("🔄 Calculating periodic ring optics with enforced boundary conditions...")
        
        result = self.get_beam_optics(lattice, branch_name, ring_params)
        
        # Verify we got a true periodic solution
        if result['calculation_mode'] != 'periodic_ring':
            raise RuntimeError(
                f"Failed to achieve periodic ring solution. Got: {result['calculation_mode']}. "
                "This lattice may not form a stable ring or may be incomplete."
            )
        
        if not result.get('periodicity_verified', False):
            max_error = result.get('periodicity_errors', {}).get('max_error_value', 'unknown')
            logger.warning(f"Periodic solution achieved but periodicity verification failed (max error: {max_error})")
        
        logger.info(f"✅ Ring optics calculated: Qx={result['tune_x']:.6f}, Qy={result['tune_y']:.6f}")
        logger.info(f"📏 Ring circumference: {result.get('circumference', result['lattice_length']):.3f} m")
        
        return result
    
    def calculate_chromaticity(self, lattice: Lattice, branch_name: str = "main", 
                             parameters: Optional[Dict[str, Any]] = None) -> Dict[str, float]:
        """
        Calculate chromaticity (tune vs momentum spread) for the lattice.
        
        Args:
            lattice: EICViBE lattice
            branch_name: Branch to analyze
            parameters: Optional parameters for calculation
            
        Returns:
            Dictionary with chromaticity values
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Set chromaticity calculation parameters
        chrom_params = {
            'compute_chromatic_functions': True,
            **(parameters or {})
        }
        
        try:
            # Get Twiss with chromaticity
            optics = self.get_beam_optics(lattice, branch_name, chrom_params)
            
            return {
                'chromaticity_x': optics.get('chromaticity_x', 0.0),
                'chromaticity_y': optics.get('chromaticity_y', 0.0),
                'tune_x': optics['tune_x'],
                'tune_y': optics['tune_y']
            }
        except Exception as e:
            # If chromaticity calculation fails, try without chromatic functions
            logger.warning(f"Chromaticity calculation with chromatic functions failed: {e}")
            logger.info("Retrying without chromatic functions...")
            
            basic_params = {**(parameters or {})}
            basic_params.pop('compute_chromatic_functions', None)
            
            optics = self.get_beam_optics(lattice, branch_name, basic_params)
            
            return {
                'chromaticity_x': 0.0,  # Not computed
                'chromaticity_y': 0.0,  # Not computed  
                'tune_x': optics['tune_x'],
                'tune_y': optics['tune_y'],
                'note': 'Chromaticity not computed due to non-periodic lattice'
            }
    
    def find_periodic_solution(self, lattice: Lattice, branch_name: str = "main",
                             parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Find periodic Twiss solution for a ring lattice.
        
        Args:
            lattice: EICViBE lattice (must be a closed ring)
            branch_name: Branch to analyze
            parameters: Optional parameters for calculation
            
        Returns:
            Dictionary with periodic Twiss parameters
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        # Convert lattice
        line = self.convert_lattice(lattice, branch_name)
        
        # Build reference particle
        ref_params = parameters.get('reference_particle', {
            'p0c': 5e9,
            'q0': -1,
            'mass0': 0.51099895e6
        }) if parameters else {
            'p0c': 5e9,
            'q0': -1,
            'mass0': 0.51099895e6
        }
        
        ref_particle = self.xpart.Particles(
            p0c=ref_params['p0c'],
            q0=ref_params['q0'],
            mass0=ref_params['mass0']
        )
        line.particle_ref = ref_particle
        line.build_tracker()
        
        try:
            # Find periodic solution (XSuite automatically does this for rings)
            twiss = line.twiss()
            
            periodic_solution = {
                'initial_conditions': {
                    'betx': float(twiss.betx[0]),
                    'bety': float(twiss.bety[0]),
                    'alfx': float(twiss.alfx[0]),
                    'alfy': float(twiss.alfy[0]),
                    'dx': float(twiss.dx[0]),
                    'dpx': float(twiss.dpx[0]),
                    'dy': float(twiss.dy[0]),
                    'dpy': float(twiss.dpy[0])
                },
                'tunes': {
                    'qx': float(twiss.qx),
                    'qy': float(twiss.qy)
                },
                'lattice_properties': {
                    'circumference': float(twiss.circumference),
                    'momentum_compaction': float(twiss.momentum_compaction_factor)
                },
                'is_stable': float(twiss.qx) > 0 and float(twiss.qy) > 0,  # Basic stability check
                'reference_particle': ref_params
            }
            
            logger.info(f"Periodic solution found: Qx={twiss.qx:.6f}, Qy={twiss.qy:.6f}")
            return periodic_solution
            
        except Exception as e:
            logger.error(f"Failed to find periodic solution: {e}")
            raise RuntimeError(f"Periodic solution calculation failed: {e}")
    
    def analyze_lattice_stability(self, lattice: Lattice, branch_name: str = "main",
                                parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Analyze lattice stability including tune analysis and resonance proximity.
        
        Args:
            lattice: EICViBE lattice
            branch_name: Branch to analyze
            parameters: Optional parameters for analysis
            
        Returns:
            Dictionary with stability analysis results
        """
        if not self.xsuite_available:
            raise RuntimeError("XSuite is not available")
        
        try:
            # Get Twiss parameters
            optics = self.get_beam_optics(lattice, branch_name, parameters)
            
            qx = optics['tune_x']
            qy = optics['tune_y']
            
            # Analyze resonance proximity
            resonances = []
            
            # Check major resonances up to 4th order
            for n in range(1, 5):
                for m in range(1, 5):
                    for p in range(-2, 3):  # -2, -1, 0, 1, 2
                        resonance_value = n * qx + m * qy
                        distance_to_integer = min(
                            abs(resonance_value - round(resonance_value)),
                            abs(resonance_value - round(resonance_value) + 1),
                            abs(resonance_value - round(resonance_value) - 1)
                        )
                        
                        if distance_to_integer < 0.1:  # Close to resonance
                            resonances.append({
                                'order': n + m,
                                'nx': n,
                                'ny': m,
                                'resonance_line': f"{n}Qx + {m}Qy = {round(resonance_value)}",
                                'distance': distance_to_integer,
                                'severity': 'critical' if distance_to_integer < 0.01 else 'warning'
                            })
            
            # Sort by proximity to resonance
            resonances.sort(key=lambda x: x['distance'])
            
            # Basic stability criteria
            beta_x_max = optics['statistics']['max_betx']
            beta_y_max = optics['statistics']['max_bety']
            
            stability_analysis = {
                'tunes': {
                    'qx': qx,
                    'qy': qy,
                    'fractional_qx': qx - int(qx),
                    'fractional_qy': qy - int(qy)
                },
                'stability_indicators': {
                    'beta_functions_reasonable': beta_x_max < 1000 and beta_y_max < 1000,
                    'tunes_positive': qx > 0 and qy > 0,
                    'tunes_reasonable': 0.1 < (qx - int(qx)) < 0.9 and 0.1 < (qy - int(qy)) < 0.9,
                    'max_beta_x': beta_x_max,
                    'max_beta_y': beta_y_max
                },
                'resonance_analysis': {
                    'nearby_resonances': resonances[:5],  # Top 5 closest resonances
                    'critical_resonances': [r for r in resonances if r['severity'] == 'critical'],
                    'total_nearby_resonances': len(resonances)
                },
                'overall_stability': 'stable' if (
                    qx > 0 and qy > 0 and 
                    beta_x_max < 1000 and beta_y_max < 1000 and
                    len([r for r in resonances if r['severity'] == 'critical']) == 0
                ) else 'unstable',
                'lattice_properties': optics.get('statistics', {})
            }
            
            return stability_analysis
            
        except Exception as e:
            logger.error(f"Stability analysis failed: {e}")
            raise RuntimeError(f"Lattice stability analysis failed: {e}")
    
    def match_twiss_parameters(self, lattice: Lattice, target_conditions: Dict[str, float],
                             variable_elements: List[str], branch_name: str = "main",
                             parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Match Twiss parameters by varying specified elements (simplified interface).
        
        Args:
            lattice: EICViBE lattice
            target_conditions: Target Twiss values (e.g., {'betx_at_ip': 1.0, 'bety_at_ip': 1.0})
            variable_elements: List of element names to vary
            branch_name: Branch to analyze
            parameters: Optional parameters
            
        Returns:
            Dictionary with matching results
        """
        logger.warning("Twiss matching is a complex optimization problem.")
        logger.warning("This is a placeholder implementation. For full matching, use XSuite's matching capabilities directly.")
        
        # This would require implementing optimization algorithms
        # For now, return current conditions and suggest manual tuning
        current_optics = self.get_beam_optics(lattice, branch_name, parameters)
        
        return {
            'matching_status': 'not_implemented',
            'current_conditions': {
                'betx_initial': current_optics['betx'][0],
                'bety_initial': current_optics['bety'][0],
                'tune_x': current_optics['tune_x'],
                'tune_y': current_optics['tune_y']
            },
            'target_conditions': target_conditions,
            'variable_elements': variable_elements,
            'suggestion': "Use XSuite's line.match() method for sophisticated matching capabilities"
        }
