"""
Base classes for physics simulation engines in EICViBE.

This module provides the foundational architecture for all physics simulation
engines (XSuite, JuTrack, etc.) with support for three operation modes:
- LINAC: Single-pass simulation with automatic re-run capability
- RING: Continuous multi-turn simulation with real-time data access
- RAMPING: Time-dependent parameter evolution during simulation
"""

import logging
import threading
import time
import numpy as np
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Callable, Union, Tuple
from collections import deque
from dataclasses import dataclass
from enum import Enum

# Configure logging
logger = logging.getLogger(__name__)


class SimulationMode(Enum):
    """Simulation operation modes."""
    LINAC = "linac"
    RING = "ring" 
    RAMPING = "ramping"


class SimulationState(Enum):
    """Simulation execution states."""
    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    COMPLETED = "completed"
    ERROR = "error"


@dataclass
class BeamStatistics:
    """Container for beam statistics at monitoring points."""
    turn: int
    timestamp: float
    x_mean: float
    y_mean: float
    x_rms: float
    y_rms: float
    x_emittance: float
    y_emittance: float
    particles_alive: int
    survival_rate: float
    energy_mean: float
    energy_spread: float


@dataclass
class MonitorData:
    """Data structure for beam position monitor readings."""
    monitor_name: str
    location_s: float  # longitudinal position in lattice
    beam_stats: BeamStatistics
    raw_data: Optional[Dict[str, np.ndarray]] = None  # particle coordinates if available


@dataclass
class RampingPlan:
    """Parameter ramping plan for time-dependent simulations."""
    element_name: str
    parameter_group: str
    parameter_name: str
    time_points: List[float]  # time values
    parameter_values: List[float]  # corresponding parameter values
    interpolation_type: str = "linear"  # linear, cubic, step


@dataclass
class SimulationStatus:
    """Current status of the running simulation."""
    is_running: bool
    is_paused: bool
    current_turn: int
    total_turns: int
    survival_rate: float
    elapsed_time: float
    particles_alive: int
    beam_statistics: Dict[str, float]


class SimulationMode(Enum):
    """Simulation mode enumeration."""
    LINAC = "linac"      # Continuous particle generation and tracking through lattice
    RING = "ring"        # Particles tracked continuously in circular lattice
    RAMPING = "ramping"  # Elements change according to time-based ramping plan


@dataclass
class RampingPlan:
    """
    Placeholder for ramping plan definition.
    
    This will define how element parameters change over time.
    Future implementation will include:
    - Time-dependent parameter functions
    - Interpolation methods
    - Synchronization with simulation time
    """
    name: str = "default"
    duration: float = 1.0  # Total ramping duration in seconds
    parameters: Dict[str, Any] = field(default_factory=dict)  # Placeholder for ramping functions
    
    def get_parameter_at_time(self, element_name: str, parameter_name: str, time: float) -> Any:
        """Get parameter value at specific time (placeholder implementation)."""
        # TODO: Implement time-dependent parameter calculation
        return self.parameters.get(f"{element_name}.{parameter_name}", 0.0)


@dataclass
class SimulationRequest:
    """Request to run a simulation with a specific lattice and mode."""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    lattice: Lattice = None
    branch_name: str = "main"
    simulation_mode: SimulationMode = SimulationMode.LINAC
    simulation_type: str = "tracking"  # Legacy field, kept for compatibility
    parameters: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    priority: int = 1  # Higher number = higher priority
    
    # Mode-specific parameters
    ramping_plan: Optional[RampingPlan] = None  # For RAMPING mode
    continuous_duration: Optional[float] = None  # For RING/LINAC continuous operation
    generation_rate: Optional[float] = None  # For LINAC mode: particles per second


@dataclass
class SimulationResult:
    """Result from a simulation run."""
    request_id: str
    success: bool
    data: Dict[str, Any] = field(default_factory=dict)
    error_message: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    computation_time: float = 0.0  # seconds
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert result to dictionary for serialization."""
        return {
            'request_id': self.request_id,
            'success': self.success,
            'data': self.data,
            'error_message': self.error_message,
            'timestamp': self.timestamp.isoformat(),
            'computation_time': self.computation_time
        }


class SimulatorServiceBase(abc.ABC):
    """
    Base class for continuous simulation services.
    
    A simulator service runs continuously in the background, processing lattice
    updates and simulation requests, and providing real-time results.
    """
    
    def __init__(self, name: str, max_queue_size: int = 100):
        """
        Initialize the simulator service.
        
        Args:
            name: Name of the simulator service
            max_queue_size: Maximum number of queued simulation requests
        """
        self.name = name
        self.is_running = False
        self.worker_thread: Optional[threading.Thread] = None
        
        # Request/result queues
        self.request_queue = queue.PriorityQueue(maxsize=max_queue_size)
        self.result_history: List[SimulationResult] = []
        self.max_history_size = 1000
        
        # Current state
        self.current_lattice: Optional[Lattice] = None
        self.current_request: Optional[SimulationRequest] = None
        self.latest_result: Optional[SimulationResult] = None
        
        # Callbacks for events
        self.result_callbacks: List[Callable[[SimulationResult], None]] = []
        self.error_callbacks: List[Callable[[Exception], None]] = []
        
        # Statistics
        self.total_simulations = 0
        self.successful_simulations = 0
        self.total_computation_time = 0.0
        
        logger.info(f"Initialized {self.name} simulator service")
    
    @abc.abstractmethod
    def setup_simulator(self) -> bool:
        """
        Set up the simulation engine (e.g., import packages, initialize).
        
        Returns:
            True if setup successful, False otherwise
        """
        pass
    
    @abc.abstractmethod
    def convert_lattice(self, lattice: Lattice, branch_name: str) -> Any:
        """
        Convert EICViBE lattice to simulator-specific format.
        
        Args:
            lattice: EICViBE lattice object
            branch_name: Name of branch to convert
            
        Returns:
            Simulator-specific lattice object
        """
        pass
    
    @abc.abstractmethod
    def run_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run the actual simulation.
        
        Args:
            sim_lattice: Simulator-specific lattice object
            parameters: Simulation parameters
            
        Returns:
            Dictionary containing simulation results
        """
        pass
    
    @abc.abstractmethod
    def run_linac_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run LINAC mode simulation.
        
        Particles are continuously generated at the beginning and tracked through
        the lattice. When particles reach the end, new particles are generated.
        
        Args:
            sim_lattice: Simulator-specific lattice object  
            parameters: Simulation parameters including:
                - generation_rate: particles per second
                - continuous_duration: total simulation time
                - particle_parameters: initial particle distribution settings
                
        Returns:
            Dictionary containing simulation results
        """
        pass
    
    @abc.abstractmethod
    def run_ring_simulation(self, sim_lattice: Any, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run RING mode simulation.
        
        Particles are generated initially and tracked continuously in the ring.
        Lattice updates are applied dynamically during simulation.
        
        Args:
            sim_lattice: Simulator-specific lattice object
            parameters: Simulation parameters including:
                - continuous_duration: total simulation time
                - num_particles: initial particle count
                - lattice_update_callback: function to check for lattice updates
                
        Returns:
            Dictionary containing simulation results
        """
        pass
    
    @abc.abstractmethod
    def run_ramping_simulation(self, sim_lattice: Any, ramping_plan: RampingPlan, 
                             parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run RAMPING mode simulation.
        
        Elements change strength according to the ramping plan. Particles are
        tracked through the time-varying lattice.
        
        Args:
            sim_lattice: Simulator-specific lattice object
            ramping_plan: Time-dependent parameter changes
            parameters: Simulation parameters
            
        Returns:
            Dictionary containing simulation results
        """
        pass
    
    @abc.abstractmethod
    def cleanup_simulator(self):
        """Clean up simulation engine resources."""
        pass
    
    def start_service(self) -> bool:
        """
        Start the continuous simulation service.
        
        Returns:
            True if service started successfully
        """
        if self.is_running:
            logger.warning(f"{self.name} service is already running")
            return True
        
        if not self.setup_simulator():
            logger.error(f"Failed to setup {self.name} simulator")
            return False
        
        self.is_running = True
        self.worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
        self.worker_thread.start()
        
        logger.info(f"{self.name} simulation service started")
        return True
    
    def stop_service(self):
        """Stop the simulation service."""
        if not self.is_running:
            return
        
        self.is_running = False
        
        # Add a stop signal to the queue
        stop_request = SimulationRequest(
            id="STOP",
            simulation_type="stop"
        )
        try:
            self.request_queue.put((0, stop_request), timeout=1.0)  # Highest priority
        except queue.Full:
            pass
        
        # Wait for worker thread to finish
        if self.worker_thread and self.worker_thread.is_alive():
            self.worker_thread.join(timeout=5.0)
        
        self.cleanup_simulator()
        logger.info(f"{self.name} simulation service stopped")
    
    def submit_simulation(self, request: SimulationRequest) -> str:
        """
        Submit a simulation request.
        
        Args:
            request: Simulation request
            
        Returns:
            Request ID
        """
        if not self.is_running:
            raise RuntimeError(f"{self.name} service is not running")
        
        try:
            # Use negative priority for queue (lower number = higher priority)
            self.request_queue.put((-request.priority, request), timeout=1.0)
            logger.info(f"Submitted simulation request {request.id} to {self.name}")
            return request.id
        except queue.Full:
            raise RuntimeError(f"{self.name} request queue is full")
    
    def update_lattice(self, lattice: Lattice, branch_name: str = "main", 
                      simulation_parameters: Optional[Dict[str, Any]] = None,
                      simulation_mode: SimulationMode = SimulationMode.LINAC) -> str:
        """
        Update the lattice and trigger a new simulation.
        
        Args:
            lattice: Updated lattice
            branch_name: Branch to simulate
            simulation_parameters: Optional simulation parameters
            simulation_mode: Simulation mode to use
            
        Returns:
            Request ID for the triggered simulation
        """
        request = SimulationRequest(
            lattice=lattice,
            branch_name=branch_name,
            simulation_mode=simulation_mode,
            simulation_type="tracking",  # Legacy compatibility
            parameters=simulation_parameters or {},
            priority=5  # High priority for lattice updates
        )
        
        return self.submit_simulation(request)
    
    def submit_linac_simulation(self, lattice: Lattice, branch_name: str = "main",
                               generation_rate: float = 1000.0, continuous_duration: float = 10.0,
                               parameters: Optional[Dict[str, Any]] = None) -> str:
        """
        Submit a LINAC mode simulation.
        
        Args:
            lattice: Lattice to simulate
            branch_name: Branch to simulate
            generation_rate: Particles generated per second
            continuous_duration: Total simulation duration
            parameters: Additional simulation parameters
            
        Returns:
            Request ID
        """
        sim_params = parameters or {}
        sim_params.update({
            'generation_rate': generation_rate,
            'continuous_duration': continuous_duration
        })
        
        request = SimulationRequest(
            lattice=lattice,
            branch_name=branch_name,
            simulation_mode=SimulationMode.LINAC,
            parameters=sim_params,
            generation_rate=generation_rate,
            continuous_duration=continuous_duration,
            priority=3
        )
        
        return self.submit_simulation(request)
    
    def submit_ring_simulation(self, lattice: Lattice, branch_name: str = "main",
                              num_particles: int = 1000, continuous_duration: float = 100.0,
                              parameters: Optional[Dict[str, Any]] = None) -> str:
        """
        Submit a RING mode simulation.
        
        Args:
            lattice: Ring lattice to simulate
            branch_name: Branch to simulate
            num_particles: Number of particles to track
            continuous_duration: Total simulation duration
            parameters: Additional simulation parameters
            
        Returns:
            Request ID
        """
        sim_params = parameters or {}
        sim_params.update({
            'num_particles': num_particles,
            'continuous_duration': continuous_duration
        })
        
        request = SimulationRequest(
            lattice=lattice,
            branch_name=branch_name,
            simulation_mode=SimulationMode.RING,
            parameters=sim_params,
            continuous_duration=continuous_duration,
            priority=3
        )
        
        return self.submit_simulation(request)
    
    def submit_ramping_simulation(self, lattice: Lattice, ramping_plan: RampingPlan,
                                 branch_name: str = "main",
                                 parameters: Optional[Dict[str, Any]] = None) -> str:
        """
        Submit a RAMPING mode simulation.
        
        Args:
            lattice: Lattice to simulate with ramping
            ramping_plan: Time-dependent parameter changes
            branch_name: Branch to simulate
            parameters: Additional simulation parameters
            
        Returns:
            Request ID
        """
        request = SimulationRequest(
            lattice=lattice,
            branch_name=branch_name,
            simulation_mode=SimulationMode.RAMPING,
            parameters=parameters or {},
            ramping_plan=ramping_plan,
            priority=4
        )
        
        return self.submit_simulation(request)
    
    def get_latest_result(self) -> Optional[SimulationResult]:
        """Get the most recent simulation result."""
        return self.latest_result
    
    def get_result_by_id(self, request_id: str) -> Optional[SimulationResult]:
        """Get simulation result by request ID."""
        for result in reversed(self.result_history):
            if result.request_id == request_id:
                return result
        return None
    
    def add_result_callback(self, callback: Callable[[SimulationResult], None]):
        """Add a callback function to be called when new results are available."""
        self.result_callbacks.append(callback)
    
    def add_error_callback(self, callback: Callable[[Exception], None]):
        """Add a callback function to be called when errors occur."""
        self.error_callbacks.append(callback)
    
    def get_service_status(self) -> Dict[str, Any]:
        """Get current service status and statistics."""
        return {
            'name': self.name,
            'is_running': self.is_running,
            'queue_size': self.request_queue.qsize(),
            'total_simulations': self.total_simulations,
            'successful_simulations': self.successful_simulations,
            'success_rate': (self.successful_simulations / max(1, self.total_simulations)) * 100,
            'average_computation_time': self.total_computation_time / max(1, self.successful_simulations),
            'current_request_id': self.current_request.id if self.current_request else None,
            'latest_result_id': self.latest_result.request_id if self.latest_result else None
        }
    
    def _worker_loop(self):
        """Main worker loop that processes simulation requests."""
        logger.info(f"{self.name} worker loop started")
        
        while self.is_running:
            try:
                # Get next request (blocking with timeout)
                try:
                    priority, request = self.request_queue.get(timeout=1.0)
                except queue.Empty:
                    continue
                
                # Check for stop signal
                if request.id == "STOP":
                    break
                
                self.current_request = request
                logger.info(f"{self.name} processing request {request.id}")
                
                # Process the simulation
                result = self._process_simulation(request)
                
                # Store result
                self.latest_result = result
                self.result_history.append(result)
                
                # Trim history if too long
                if len(self.result_history) > self.max_history_size:
                    self.result_history = self.result_history[-self.max_history_size:]
                
                # Update statistics
                self.total_simulations += 1
                if result.success:
                    self.successful_simulations += 1
                    self.total_computation_time += result.computation_time
                
                # Call result callbacks
                for callback in self.result_callbacks:
                    try:
                        callback(result)
                    except Exception as e:
                        logger.error(f"Error in result callback: {e}")
                
                self.current_request = None
                
            except Exception as e:
                logger.error(f"Error in {self.name} worker loop: {e}")
                
                # Call error callbacks
                for callback in self.error_callbacks:
                    try:
                        callback(e)
                    except Exception as callback_error:
                        logger.error(f"Error in error callback: {callback_error}")
        
        logger.info(f"{self.name} worker loop finished")
    
    def _process_simulation(self, request: SimulationRequest) -> SimulationResult:
        """Process a single simulation request based on its mode."""
        start_time = time.time()
        
        try:
            # Convert lattice to simulator format
            if request.lattice is None:
                raise ValueError("No lattice provided in simulation request")
            
            sim_lattice = self.convert_lattice(request.lattice, request.branch_name)
            
            # Run simulation based on mode
            if request.simulation_mode == SimulationMode.LINAC:
                sim_data = self.run_linac_simulation(sim_lattice, request.parameters)
            elif request.simulation_mode == SimulationMode.RING:
                sim_data = self.run_ring_simulation(sim_lattice, request.parameters)
            elif request.simulation_mode == SimulationMode.RAMPING:
                if request.ramping_plan is None:
                    raise ValueError("Ramping plan required for RAMPING mode")
                sim_data = self.run_ramping_simulation(sim_lattice, request.ramping_plan, request.parameters)
            else:
                # Fallback to legacy run_simulation method
                sim_data = self.run_simulation(sim_lattice, request.parameters)
            
            # Add mode information to results
            sim_data['simulation_mode'] = request.simulation_mode.value
            if request.ramping_plan:
                sim_data['ramping_plan_name'] = request.ramping_plan.name
            
            # Create successful result
            computation_time = time.time() - start_time
            
            result = SimulationResult(
                request_id=request.id,
                success=True,
                data=sim_data,
                computation_time=computation_time
            )
            
            logger.info(f"{self.name} completed {request.simulation_mode.value} simulation {request.id} in {computation_time:.3f}s")
            return result
            
        except Exception as e:
            # Create error result
            computation_time = time.time() - start_time
            
            result = SimulationResult(
                request_id=request.id,
                success=False,
                error_message=str(e),
                computation_time=computation_time
            )
            
            logger.error(f"{self.name} {request.simulation_mode.value if hasattr(request, 'simulation_mode') else 'unknown'} simulation {request.id} failed: {e}")
            return result


class SimulatorManager:
    """
    Manager for multiple simulator services.
    
    Coordinates multiple simulation engines and provides a unified interface.
    """
    
    def __init__(self):
        self.simulators: Dict[str, SimulatorServiceBase] = {}
        self.global_callbacks: List[Callable[[str, SimulationResult], None]] = []
    
    def register_simulator(self, simulator: SimulatorServiceBase):
        """Register a simulator service."""
        self.simulators[simulator.name] = simulator
        
        # Add global callback to simulator
        def global_callback(result: SimulationResult):
            for callback in self.global_callbacks:
                try:
                    callback(simulator.name, result)
                except Exception as e:
                    logger.error(f"Error in global callback: {e}")
        
        simulator.add_result_callback(global_callback)
        logger.info(f"Registered simulator: {simulator.name}")
    
    def start_all_services(self) -> Dict[str, bool]:
        """Start all registered simulator services."""
        results = {}
        for name, simulator in self.simulators.items():
            results[name] = simulator.start_service()
        return results


class AsyncSimulatorBase(abc.ABC):
    """
    Base class for asynchronous simulation managers.
    
    Provides threading infrastructure, command queues, and communication protocols
    that can be used by any simulation engine for real-time parameter updates
    during long-running simulations.
    """
    
    def __init__(self, line, particles, sim_params):
        """
        Initialize the base async simulator.
        
        Args:
            line: Simulation lattice/line object (engine-specific)
            particles: Particle distribution object (engine-specific) 
            sim_params: Simulation parameters dictionary
        """
        self.line = line
        self.particles = particles
        self.sim_params = sim_params
        
        # Communication infrastructure
        self.command_queue = queue.Queue()
        self.response_queue = queue.Queue()
        self.status_callbacks = []
        
        # Simulation state
        self.is_running = False
        self.is_paused = False
        self.should_stop = False
        self.current_turn = 0
        self.start_time = None
        
        # Simulation timing control
        self.turn_delay = sim_params.get('turn_delay', 0.0)  # Delay between turns in seconds
        
        # Data storage
        self.survival_history = []
        self.turn_data = []
        self.pending_updates = []  # List of ElementUpdate objects
        
        # Threading
        self.simulation_thread = None
        self.communication_thread = None
        
        # Callbacks for external communication
        self.turn_callback = None  # Called after each turn
        self.status_callback = None  # Called periodically with status
    
    def start_simulation(self, num_turns: int, 
                        turn_callback: Optional[Callable] = None,
                        status_callback: Optional[Callable] = None):
        """Start the asynchronous simulation."""
        if self.is_running:
            raise RuntimeError("Simulation is already running")
        
        self.turn_callback = turn_callback
        self.status_callback = status_callback
        self.current_turn = 0
        self.should_stop = False
        self.is_paused = False
        self.start_time = time.time()
        
        # Start simulation thread
        self.simulation_thread = threading.Thread(
            target=self._simulation_loop,
            args=(num_turns,),
            daemon=True
        )
        
        # Start communication thread
        self.communication_thread = threading.Thread(
            target=self._communication_loop,
            daemon=True
        )
        
        self.is_running = True
        self.simulation_thread.start()
        self.communication_thread.start()
        
        logger.info(f"Started asynchronous simulation for {num_turns} turns")
    
    @abc.abstractmethod
    def _simulation_loop(self, num_turns: int):
        """
        Main simulation loop running in separate thread.
        
        This method must be implemented by each simulation engine to handle:
        - Engine-specific particle tracking
        - Statistics collection
        - Parameter update application
        - Progress monitoring
        
        Args:
            num_turns: Number of turns to simulate
        """
        pass
    
    @abc.abstractmethod  
    def _apply_element_update(self, update: ElementUpdate):
        """
        Apply a parameter update to a lattice element.
        
        This method must be implemented by each simulation engine to handle
        engine-specific parameter mapping and element modification.
        
        Args:
            update: ElementUpdate object containing parameter change details
        """
        pass
    
    @abc.abstractmethod
    def _get_current_status(self) -> SimulationStatus:
        """
        Get current simulation status.
        
        This method must be implemented by each simulation engine to provide
        engine-specific status information.
        
        Returns:
            SimulationStatus object with current simulation state
        """
        pass
    
    def _communication_loop(self):
        """Communication loop for handling commands during simulation."""
        while self.is_running or not self.command_queue.empty():
            try:
                # Get command with timeout
                command, data = self.command_queue.get(timeout=0.1)
                response = self._handle_command(command, data)
                self.response_queue.put(response)
                self.command_queue.task_done()
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Error in communication loop: {e}")
    
    def _handle_command(self, command: SimulationCommand, data: Any) -> Any:
        """Handle incoming commands during simulation."""
        if command == SimulationCommand.UPDATE_ELEMENT:
            return self._schedule_element_update(data)
        elif command == SimulationCommand.PAUSE:
            self.is_paused = True
            return {"status": "paused", "turn": self.current_turn}
        elif command == SimulationCommand.RESUME:
            self.is_paused = False
            return {"status": "resumed", "turn": self.current_turn}
        elif command == SimulationCommand.STOP:
            self.should_stop = True
            return {"status": "stopping", "turn": self.current_turn}
        elif command == SimulationCommand.GET_STATUS:
            return self._get_current_status()
        elif command == SimulationCommand.SAVE_SNAPSHOT:
            return self._save_particle_snapshot()
        else:
            return {"error": f"Unknown command: {command}"}
    
    def _schedule_element_update(self, update: ElementUpdate) -> Dict[str, Any]:
        """Schedule an element parameter update."""
        try:
            if update.turn_number is None or update.turn_number <= self.current_turn:
                # Apply immediately
                self._apply_element_update(update)
                return {"status": "applied_immediately", "turn": self.current_turn}
            else:
                # Schedule for future turn
                self.pending_updates.append(update)
                return {"status": "scheduled", "target_turn": update.turn_number}
        except Exception as e:
            return {"error": str(e)}
    
    def _apply_pending_updates(self, turn: int):
        """Apply any parameter updates scheduled for this turn."""
        updates_to_apply = [u for u in self.pending_updates if u.turn_number == turn]
        for update in updates_to_apply:
            try:
                self._apply_element_update(update)
                self.pending_updates.remove(update)
            except Exception as e:
                logger.error(f"Failed to apply update at turn {turn}: {e}")
    
    def _save_particle_snapshot(self) -> Dict[str, Any]:
        """
        Save current particle state snapshot.
        
        Base implementation - can be overridden by simulation engines
        for engine-specific particle data formats.
        """
        return {
            'turn': self.current_turn,
            'timestamp': time.time(),
            'status': 'snapshot_not_implemented'
        }
    
    def send_command(self, command: SimulationCommand, data: Any = None, timeout: float = 5.0) -> Any:
        """Send a command to the running simulation and wait for response."""
        if not self.is_running:
            raise RuntimeError("Simulation is not running")
        
        self.command_queue.put((command, data))
        
        try:
            response = self.response_queue.get(timeout=timeout)
            return response
        except queue.Empty:
            raise TimeoutError(f"Command {command} timed out after {timeout}s")
    
    def update_element_parameter(self, element_name: str, parameter_group: str, 
                                parameter_name: str, new_value: float, 
                                target_turn: Optional[int] = None) -> Dict[str, Any]:
        """Update an element parameter during simulation."""
        update = ElementUpdate(
            element_name=element_name,
            parameter_group=parameter_group,
            parameter_name=parameter_name,
            new_value=new_value,
            turn_number=target_turn
        )
        return self.send_command(SimulationCommand.UPDATE_ELEMENT, update)
    
    def pause_simulation(self) -> Dict[str, Any]:
        """Pause the running simulation."""
        return self.send_command(SimulationCommand.PAUSE)
    
    def resume_simulation(self) -> Dict[str, Any]:
        """Resume the paused simulation."""
        return self.send_command(SimulationCommand.RESUME)
    
    def stop_simulation(self) -> Dict[str, Any]:
        """Stop the running simulation."""
        return self.send_command(SimulationCommand.STOP)
    
    def get_status(self) -> SimulationStatus:
        """Get current simulation status."""
        response = self.send_command(SimulationCommand.GET_STATUS)
        if isinstance(response, SimulationStatus):
            return response
        else:
            # Convert dict response to SimulationStatus if needed
            return SimulationStatus(**response)
    
    def get_particle_snapshot(self) -> Dict[str, Any]:
        """Get current particle snapshot."""
        return self.send_command(SimulationCommand.SAVE_SNAPSHOT)
    
    def wait_for_completion(self, check_interval: float = 1.0):
        """Wait for simulation to complete."""
        while self.is_running:
            time.sleep(check_interval)
        
        if self.simulation_thread:
            self.simulation_thread.join()
        if self.communication_thread:
            self.communication_thread.join()
    
    def get_results(self) -> Dict[str, Any]:
        """Get final simulation results."""
        final_survival_rate = self.survival_history[-1] if self.survival_history else 0.0
        
        return {
            'simulation_type': 'async_tracking',
            'num_turns_completed': self.current_turn,
            'final_survival_rate': float(final_survival_rate),
            'survival_history': [float(sr) for sr in self.survival_history],
            'turn_statistics': self.turn_data,
            'total_time': time.time() - self.start_time if self.start_time else 0.0,
            'simulation_parameters': self.sim_params
        }
    
    def stop_all_services(self):
        """Stop all simulator services."""
        for simulator in self.simulators.values():
            simulator.stop_service()
    
    def update_lattice_for_all(self, lattice: Lattice, branch_name: str = "main",
                              simulation_parameters: Optional[Dict[str, Any]] = None,
                              simulation_mode: SimulationMode = SimulationMode.LINAC) -> Dict[str, str]:
        """
        Update lattice for all simulators.
        
        Args:
            lattice: Updated lattice
            branch_name: Branch to simulate
            simulation_parameters: Optional simulation parameters
            simulation_mode: Simulation mode to use
        
        Returns:
            Dictionary mapping simulator names to request IDs
        """
        request_ids = {}
        for name, simulator in self.simulators.items():
            if simulator.is_running:
                try:
                    request_id = simulator.update_lattice(lattice, branch_name, simulation_parameters, simulation_mode)
                    request_ids[name] = request_id
                except Exception as e:
                    logger.error(f"Failed to update lattice for {name}: {e}")
        
        return request_ids
    
    def start_linac_simulation_for_all(self, lattice: Lattice, branch_name: str = "main",
                                      generation_rate: float = 1000.0, continuous_duration: float = 10.0,
                                      parameters: Optional[Dict[str, Any]] = None) -> Dict[str, str]:
        """
        Start LINAC mode simulation on all simulators.
        
        Returns:
            Dictionary mapping simulator names to request IDs
        """
        request_ids = {}
        for name, simulator in self.simulators.items():
            if simulator.is_running:
                try:
                    request_id = simulator.submit_linac_simulation(
                        lattice, branch_name, generation_rate, continuous_duration, parameters
                    )
                    request_ids[name] = request_id
                except Exception as e:
                    logger.error(f"Failed to start LINAC simulation for {name}: {e}")
        
        return request_ids
    
    def start_ring_simulation_for_all(self, lattice: Lattice, branch_name: str = "main",
                                     num_particles: int = 1000, continuous_duration: float = 100.0,
                                     parameters: Optional[Dict[str, Any]] = None) -> Dict[str, str]:
        """
        Start RING mode simulation on all simulators.
        
        Returns:
            Dictionary mapping simulator names to request IDs
        """
        request_ids = {}
        for name, simulator in self.simulators.items():
            if simulator.is_running:
                try:
                    request_id = simulator.submit_ring_simulation(
                        lattice, branch_name, num_particles, continuous_duration, parameters
                    )
                    request_ids[name] = request_id
                except Exception as e:
                    logger.error(f"Failed to start RING simulation for {name}: {e}")
        
        return request_ids
    
    def start_ramping_simulation_for_all(self, lattice: Lattice, ramping_plan: RampingPlan,
                                        branch_name: str = "main",
                                        parameters: Optional[Dict[str, Any]] = None) -> Dict[str, str]:
        """
        Start RAMPING mode simulation on all simulators.
        
        Returns:
            Dictionary mapping simulator names to request IDs
        """
        request_ids = {}
        for name, simulator in self.simulators.items():
            if simulator.is_running:
                try:
                    request_id = simulator.submit_ramping_simulation(
                        lattice, ramping_plan, branch_name, parameters
                    )
                    request_ids[name] = request_id
                except Exception as e:
                    logger.error(f"Failed to start RAMPING simulation for {name}: {e}")
        
        return request_ids
    
    def get_all_latest_results(self) -> Dict[str, Optional[SimulationResult]]:
        """Get latest results from all simulators."""
        return {name: sim.get_latest_result() for name, sim in self.simulators.items()}
    
    def get_all_service_status(self) -> Dict[str, Dict[str, Any]]:
        """Get status of all simulator services."""
        return {name: sim.get_service_status() for name, sim in self.simulators.items()}
    
    def add_global_callback(self, callback: Callable[[str, SimulationResult], None]):
        """Add a global callback that receives results from all simulators."""
        self.global_callbacks.append(callback)
